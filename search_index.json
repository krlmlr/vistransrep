[
["index.html", "Visualization, transformation and reporting with the tidyverse Preface Links to material for past workshops Links Download data and code Package versions used License Speakers Introduction", " Visualization, transformation and reporting with the tidyverse Kirill Müller, Tobias Schieferdecker, Patrick Schratz 29 November 2019, 08:58 CET Preface See the controls at the top of the website for searching, font size, editing, and a link to the PDF version of the material. Links to material for past workshops 2019-04 2018-12 2018-11 2018-11 2018-05 2017-10 Links This website: https://krlmlr.github.io/vistransrep Scripts and installation instructions: https://github.com/krlmlr/vistransrep-proj/tree/master Prepared scripts: https://github.com/krlmlr/vistransrep-proj/tree/master/script The source project for this material: https://github.com/krlmlr/vistransrep Download data and code # install.packages(&quot;usethis&quot;) usethis::use_course(&quot;krlmlr/vistransrep-proj&quot;) Package versions used Click to expand withr::with_options(list(width = 80), print(sessioninfo::session_info())) ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 3.6.1 (2017-01-27) ## os Ubuntu 16.04.6 LTS ## system x86_64, linux-gnu ## ui X11 ## language en_US.UTF-8 ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2019-11-29 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## askpass 1.1 2019-01-13 [1] CRAN (R 3.6.1) ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 3.6.1) ## backports 1.1.5 2019-10-02 [1] CRAN (R 3.6.1) ## beeswarm 0.2.3 2016-04-25 [1] CRAN (R 3.6.1) ## bookdown 0.16 2019-11-22 [1] CRAN (R 3.6.1) ## broom 0.5.2 2019-04-07 [1] CRAN (R 3.6.1) ## cellranger 1.1.0 2016-07-27 [1] CRAN (R 3.6.1) ## cli 1.1.0 2019-03-19 [1] CRAN (R 3.6.1) ## codetools 0.2-16 2018-12-24 [3] CRAN (R 3.6.1) ## colorspace 1.4-1 2019-03-18 [1] CRAN (R 3.6.1) ## conflicted * 1.0.4 2019-06-21 [1] CRAN (R 3.6.1) ## crayon 1.3.4 2017-09-16 [1] CRAN (R 3.6.1) ## crosstalk 1.0.0 2016-12-21 [1] CRAN (R 3.6.1) ## curl 4.2 2019-09-24 [1] CRAN (R 3.6.1) ## data.table 1.12.6 2019-10-18 [1] CRAN (R 3.6.1) ## DBI 1.0.0 2018-05-02 [1] CRAN (R 3.6.1) ## dbplyr 1.4.2 2019-06-17 [1] CRAN (R 3.6.1) ## digest 0.6.23 2019-11-23 [1] CRAN (R 3.6.1) ## dplyr * 0.8.3 2019-07-04 [1] CRAN (R 3.6.1) ## DT 0.10 2019-11-12 [1] CRAN (R 3.6.1) ## ellipsis 0.3.0 2019-09-20 [1] CRAN (R 3.6.1) ## evaluate 0.14 2019-05-28 [1] CRAN (R 3.6.1) ## fansi 0.4.0 2018-10-05 [1] CRAN (R 3.6.1) ## farver 2.0.1 2019-11-13 [1] CRAN (R 3.6.1) ## fastmap 1.0.1 2019-10-08 [1] CRAN (R 3.6.1) ## forcats * 0.4.0 2019-02-17 [1] CRAN (R 3.6.1) ## foreign 0.8-71 2018-07-20 [3] CRAN (R 3.6.1) ## fs 1.3.1 2019-05-06 [1] CRAN (R 3.6.1) ## gapminder * 0.3.0 2017-10-31 [1] CRAN (R 3.6.1) ## gdtools * 0.2.1 2019-10-14 [1] CRAN (R 3.6.1) ## generics 0.0.2 2018-11-29 [1] CRAN (R 3.6.1) ## gganimate * 1.0.4 2019-11-18 [1] CRAN (R 3.6.1) ## ggbeeswarm * 0.6.0 2017-08-07 [1] CRAN (R 3.6.1) ## ggforce * 0.3.1 2019-08-20 [1] CRAN (R 3.6.1) ## ggiraph * 0.7.0 2019-10-31 [1] CRAN (R 3.6.1) ## ggplot2 * 3.2.1 2019-08-10 [1] CRAN (R 3.6.1) ## ggpmisc * 0.3.2 2019-11-11 [1] CRAN (R 3.6.1) ## ggpubr * 0.2.4 2019-11-14 [1] CRAN (R 3.6.1) ## ggrepel * 0.8.1 2019-05-07 [1] CRAN (R 3.6.1) ## ggsci * 2.9 2018-05-14 [1] CRAN (R 3.6.1) ## ggsignif 0.6.0 2019-08-08 [1] CRAN (R 3.6.1) ## ggtext 0.1.0 2019-11-27 [1] Github (clauswilke/ggtext@cc8ea0c) ## ggthemes 4.2.0 2019-05-13 [1] CRAN (R 3.6.1) ## git2r 0.26.1 2019-06-29 [1] CRAN (R 3.6.1) ## glue 1.3.1 2019-03-12 [1] CRAN (R 3.6.1) ## gridtext 0.1.0 2019-11-27 [1] Github (clauswilke/gridtext@9378f70) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 3.6.1) ## haven 2.2.0 2019-11-08 [1] CRAN (R 3.6.1) ## here * 0.1 2017-05-28 [1] CRAN (R 3.6.1) ## hms 0.5.2 2019-10-30 [1] CRAN (R 3.6.1) ## htmltools 0.4.0 2019-10-04 [1] CRAN (R 3.6.1) ## htmlwidgets 1.5.1 2019-10-08 [1] CRAN (R 3.6.1) ## httpuv 1.5.2 2019-09-11 [1] CRAN (R 3.6.1) ## httr 1.4.1 2019-08-05 [1] CRAN (R 3.6.1) ## jpeg 0.1-8.1 2019-10-24 [1] CRAN (R 3.6.1) ## jsonlite 1.6 2018-12-07 [1] CRAN (R 3.6.1) ## knitr 1.26 2019-11-12 [1] CRAN (R 3.6.1) ## labeling 0.3 2014-08-23 [1] CRAN (R 3.6.1) ## later 1.0.0 2019-10-04 [1] CRAN (R 3.6.1) ## lattice 0.20-38 2018-11-04 [3] CRAN (R 3.6.1) ## lazyeval 0.2.2 2019-03-15 [1] CRAN (R 3.6.1) ## leaflet * 2.0.3 2019-11-16 [1] CRAN (R 3.6.1) ## lifecycle 0.1.0 2019-08-01 [1] CRAN (R 3.6.1) ## lubridate 1.7.4 2018-04-11 [1] CRAN (R 3.6.1) ## magrittr * 1.5 2014-11-22 [1] CRAN (R 3.6.1) ## markdown 1.1 2019-08-07 [1] CRAN (R 3.6.1) ## MASS 7.3-51.4 2019-03-31 [3] CRAN (R 3.6.1) ## memoise 1.1.0 2017-04-21 [1] CRAN (R 3.6.1) ## mime 0.7 2019-06-11 [1] CRAN (R 3.6.1) ## modelr 0.1.5 2019-08-08 [1] CRAN (R 3.6.1) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 3.6.1) ## nlme 3.1-140 2019-05-12 [3] CRAN (R 3.6.1) ## nycflights13 * 1.0.1 2019-09-16 [1] CRAN (R 3.6.1) ## openssl 1.4.1 2019-07-18 [1] CRAN (R 3.6.1) ## openxlsx 4.1.3 2019-11-07 [1] CRAN (R 3.6.1) ## patchwork * 0.0.1.9000 2019-11-28 [1] Github (thomasp85/patchwork@9c1e283) ## pillar 1.4.2 2019-06-29 [1] CRAN (R 3.6.1) ## pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 3.6.1) ## plotly * 4.9.1 2019-11-07 [1] CRAN (R 3.6.1) ## plyr 1.8.4 2016-06-08 [1] CRAN (R 3.6.1) ## png 0.1-7 2013-12-03 [1] CRAN (R 3.6.1) ## polyclip 1.10-0 2019-03-14 [1] CRAN (R 3.6.1) ## prettyunits 1.0.2 2015-07-13 [1] CRAN (R 3.6.1) ## progress 1.2.2 2019-05-16 [1] CRAN (R 3.6.1) ## promises 1.1.0 2019-10-04 [1] CRAN (R 3.6.1) ## purrr * 0.3.3 2019-10-18 [1] CRAN (R 3.6.1) ## R6 2.4.1 2019-11-12 [1] CRAN (R 3.6.1) ## RColorBrewer 1.1-2 2014-12-07 [1] CRAN (R 3.6.1) ## Rcpp 1.0.3 2019-11-08 [1] CRAN (R 3.6.1) ## readr * 1.3.1 2018-12-21 [1] CRAN (R 3.6.1) ## readxl 1.3.1 2019-03-13 [1] CRAN (R 3.6.1) ## reprex 0.3.0 2019-05-16 [1] CRAN (R 3.6.1) ## reshape2 1.4.3 2017-12-11 [1] CRAN (R 3.6.1) ## rio 0.5.16 2018-11-26 [1] CRAN (R 3.6.1) ## rlang 0.4.2.9000 2019-11-27 [1] Github (r-lib/rlang@1be25e7) ## rmarkdown 1.18 2019-11-27 [1] CRAN (R 3.6.1) ## rprojroot 1.3-2 2018-01-03 [1] CRAN (R 3.6.1) ## rstudioapi 0.10 2019-03-19 [1] CRAN (R 3.6.1) ## rvest 0.3.5 2019-11-08 [1] CRAN (R 3.6.1) ## scales 1.1.0 2019-11-18 [1] CRAN (R 3.6.1) ## sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 3.6.1) ## shiny 1.4.0 2019-10-10 [1] CRAN (R 3.6.1) ## stringi 1.4.3 2019-03-12 [1] CRAN (R 3.6.1) ## stringr * 1.4.0 2019-02-10 [1] CRAN (R 3.6.1) ## systemfonts 0.1.1 2019-07-01 [1] CRAN (R 3.6.1) ## tibble * 2.1.3 2019-06-06 [1] CRAN (R 3.6.1) ## tic 0.2.13.9021 2019-11-28 [1] Github (ropenscilabs/tic@4760093) ## tidyr * 1.0.0 2019-09-11 [1] CRAN (R 3.6.1) ## tidyselect 0.2.5 2018-10-11 [1] CRAN (R 3.6.1) ## tidyverse * 1.3.0 2019-11-21 [1] CRAN (R 3.6.1) ## tinytex 0.17 2019-10-30 [1] CRAN (R 3.6.1) ## tweenr 1.0.1 2018-12-14 [1] CRAN (R 3.6.1) ## utf8 1.1.4 2018-05-24 [1] CRAN (R 3.6.1) ## uuid 0.1-2 2015-07-28 [1] CRAN (R 3.6.1) ## vctrs 0.2.0 2019-07-05 [1] CRAN (R 3.6.1) ## vipor 0.4.5 2017-03-22 [1] CRAN (R 3.6.1) ## viridisLite 0.3.0 2018-02-01 [1] CRAN (R 3.6.1) ## withr 2.1.2 2018-03-15 [1] CRAN (R 3.6.1) ## xaringan 0.13 2019-10-30 [1] CRAN (R 3.6.1) ## xfun 0.11 2019-11-12 [1] CRAN (R 3.6.1) ## xml2 1.2.2 2019-08-09 [1] CRAN (R 3.6.1) ## xtable 1.8-4 2019-04-21 [1] CRAN (R 3.6.1) ## yaml 2.2.0 2018-07-25 [1] CRAN (R 3.6.1) ## zeallot 0.1.0 2018-01-28 [1] CRAN (R 3.6.1) ## zip 2.0.4 2019-09-01 [1] CRAN (R 3.6.1) ## ## [1] /home/travis/R/Library ## [2] /usr/local/lib/R/site-library ## [3] /home/travis/R-bin/lib/R/library License Licensed under CC-BY-NC 4.0. Speakers Kirill Müller (@krlmlr) https://www.cynkra.com/about.html Co-founder cynkra Computer + data science Workflows, user interfaces, databases R package author + maintainer Patrick Schratz (@pat-s) https://pat-s.me M.Sc. Geoinformatics Researcher/Research Engineer at University of Jena and LMU Munich PhD Candidate Unix &amp; R enthusiast Author/Contributor/Maintainer of several R packages: (mlr3, mlr) sperrorest oddsratio xaringan circle RQGIS travis tic … Introduction Figure 0.1: © Allison Horst The tidyverse has quickly developed over the last years. Its first implementation as a collection of partly older packages was in the second half of 2016. All its packages “share an underlying design philosophy, grammar, and data structures.”1 It is for sure difficult to tell, if “learning the tidyverse” is a hard task, since the result of this assessment might differ from person to person. We do believe though, that there are concepts in its approach, which – when grasped – have the potential to increase one’s productivity, since code creation will seem more natural. While this might be true for all languages (once you speak it well enough, things go smoothly), in our opinion the tidyverse worth exploring in depth, since it is consistent: an especially well designed framework that aims at making data analysis and programming intuitive, evolving: constantly deepened understanding for challenges arising in modern data analysis leads to improving ergonomic user interfaces. This course covers several topics, which everyone working more intently with the tidyverse almost inevitably needs to deal with at some point or another. The topics are organized in chapters that contain mostly R code with output and text. In each section, exercises are provided. Figure 0.2: © Allison Horst citation from tidyverse homepage↩ "],
["r-and-rstudio.html", "1 R and RStudio 1.1 R as a toolkit 1.2 R code examples 1.3 R vs. RStudio 1.4 R vs. R packages 1.5 R packages 1.6 .Rprofile 1.7 .Renviron 1.8 RStudio 1.9 RStudio addins 1.10 RStudio projects 1.11 Alternatives to RStudio", " 1 R and RStudio 1.1 R as a toolkit R as a toolkit Scriptability \\(\\rightarrow\\) R Literate programming (code, narrative, output in one place) \\(\\rightarrow\\) R Markdown Version control \\(\\rightarrow\\) Git / GitHub 1.1.1 Why R and RStudio? 1.1.2 Some R basics You will load packages at the start of every new R session. “Base” R comes with tons of useful built-in functions. It also provides all the tools necessary for you to write your own functions. However, many of R’s best data science functions and tools come from external packages written by other users. R easily and infinitely parallelizes. For free. Compare the cost of a Stata/MP license, nevermind the fact that you effectively pay per core… 1.2 R code examples 1.2.1 Linear regression fit &lt;- lm(dist ~ 1 + speed, data = cars) summary(fit) ## ## Call: ## lm(formula = dist ~ 1 + speed, data = cars) ## ## Residuals: ## Min 1Q Median 3Q Max ## -29.069 -9.525 -2.272 9.215 43.201 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -17.5791 6.7584 -2.601 0.0123 * ## speed 3.9324 0.4155 9.464 1.49e-12 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 15.38 on 48 degrees of freedom ## Multiple R-squared: 0.6511, Adjusted R-squared: 0.6438 ## F-statistic: 89.57 on 1 and 48 DF, p-value: 1.49e-12 1.2.2 Base R plot plot(cars, pch = 19, col = &quot;darkgray&quot;) abline(fit, lwd = 2) 1.2.3 ggplot2 library(ggplot2) library(gapminder) ## For the gapminder data ggplot( data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp) ) + geom_point() 1.2.4 gganimate 1.3 R vs. RStudio R is a statistical programming language RStudio is a convenient interface for R (an integrated development environment, IDE) At its simplest: R is like a car’s engine RStudio is like a car’s dashboard Engine vs. dashboard 1.4 R vs. R packages R packages extend the functionality of R by providing additional functions, data, and documentation. They are written by a world-wide community of R users and can be downloaded for no cost R versus R packages 1.5 R packages CRAN: A group of people who check that packages fulfill certain standards Mirror: A location on the web where to download R packages from. Because many thousand people download them daily, the load is distributed on different machines. Pick one which is geographically close to you R base/recommended packages: The base installation of R ships with a bunch of default packages. In addition, there are some more packages listed as “recommended”. “base” packages are managed by the R core team and will only be updated for every R release. Packages listed as “recommended” inherit the attributes of being widely used and having a long history in the R community. ## Package Priority ## 1 base base ## 2 compiler base ## 3 datasets base ## 4 graphics base ## 5 grDevices base ## 6 grid base ## 7 methods base ## 8 parallel base ## Package Priority ## 1 boot recommended ## 2 class recommended ## 3 cluster recommended ## 4 codetools recommended ## 5 foreign recommended ## 6 KernSmooth recommended ## 7 lattice recommended ## 8 MASS recommended ## 9 Matrix recommended ## 10 mgcv recommended ## [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 2 rows ] 1.6 .Rprofile File in your home directory ~/.Rprofile Will be executed before every R session starts Useful to set global options and for loading of often used packages 1.7 .Renviron File in your home directory ~/.Renviron Used to set environment variables Used to store “Access tokens” (Github, CI provider, C++ flags) 1.8 RStudio \\(\\rightarrow\\) Exists to boost your productivity \\(\\rightarrow\\) Change the defaults to your liking so you actually can be productive \\(\\rightarrow\\) Keybindings = productivity Since RStudio v1.3 a portable JSON settings file exists. If you want to have sane settings without much hassle, you can execute the following R code: source(&quot;https://bit.ly/rstudio-pat&quot;) This code will change/overwrite your existing RStudio settings and set custom keybindings move the console panel to the top-right (by default bottom-left) Enable/Disable some core settings to have a better overall experience R scripts (source code) are written in the Source pane (Editor). Source pane (Source of all following RStudio screenshots: https://github.com/edrubin/EC525S19) You can use the menubar or ⇧+⌘+N / ⇧+CTRL+N to create new R scripts. New script To execute commands from your R script, use ⌘+Enter / CTRL+Enter. Execute commands RStudio will execute the command in the console. Console output You can see the new object in the Environment pane. Environment pane The History tab records your old commands. History pane The Files pane is the file explorer. Files pane The Plots pane/tab shows… plots. Plots pane Packages shows installed packages Packages pane Packages shows installed packages and whether they are loaded. Loaded and installed packages The Help tab shows help documentation (also accessible via ?). Help pane Finally, you can customize the actual layout Customize layout 1.9 RStudio addins RStudio can be further enhanced by so called “addins”. These are clickable snippets that execute certain actions in RStudio. They aim to make repetitive tasks easier and to save you time. There is an addin called addinslist which lists all available addins. It can be installed as a normal package from CRAN: install.packages(&quot;addinslist&quot;) To have an addin available in RStudio after installation, RStudio needs to be restarted. 1.10 RStudio projects Without a project, you will need to define long file paths which only exist on your machine. sample_df &lt;- read.csv(&quot;/Users/&lt;yourname&gt;/somewhere/on/this/machine/sample.csv&quot;) With a project, R automatically references the project’s folder as the current working directory. From there on, you can use relative paths to point to files. sample_df &lt;- read.csv(&quot;sample.csv&quot;) Double-plus bonus: The here package extends RStudio project philosophy even more and helps in cases when not using RStudio (e.g. on the command line). Figure 1.1: © Allison Horst 1.11 Alternatives to RStudio Using R directly in the terminal via radian (optimized R console interpreter) R is supported in other “general purpose IDE’s” (VScode, Sublime Text, Atom, Vim, etc.) "],
["vis-basics.html", "2 Visualization 2.1 Basics for visualisation in R using {ggplot2} 2.2 geom_* functions 2.3 Two variable plots 2.4 One variable plots 2.5 Colors and shape 2.6 Labels 2.7 Themes 2.8 Scales 2.9 Export &amp; saving 2.10 Facetting 2.11 Extensions", " 2 Visualization Embracing the grammar of graphics. This chapter discusses plotting with the ggplot2 package. Figure 2.1: © Allison Horst 2.1 Basics for visualisation in R using {ggplot2} Click here to show setup code. library(tidyverse) In the {tidyverse} the standard package for visualization is {ggplot2}. The functions of this package follow a quite unique logic (the “grammar of graphics”) and therefore require a special syntax. In this section we want to give a short introduction, how to get started with {ggplot2}. Figure 2.2: © Allison Horst 2.1.1 Creating the plot skeleton: ggplot() The main function in the package is ggplot(), which prepares/creates a graph. By setting the arguments of the function, you can: Choose the dataset to be plotted (argument data) Choose the mapping of the variables to the axes (or further forms of setting apart data) in the argument mapping. This argument takes the result of the function aes(), which you will get to know in many different examples. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) This created only an empty plot, because we did not tell {ggplot2} which geometry we want to use to display the variables we set in the ggplot() call. We do this by adding (with the help of the + operator after the ggplot()-call) a different function starting with geom_ to provide this information. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point() This is maybe the most basic plot you can create. To map a different variable than disp to the x-axis, change the respective variable name in the aes() argument. ggplot( data = mpg, mapping = aes(x = cyl, y = hwy) ) + geom_point() You can exchange the variables to be plotted freely, without changing anything else to the rest of the code. ggplot( data = mpg, mapping = aes(x = hwy, y = cty) ) + geom_point() Always good to have: The ggplot2 cheatsheet (https://github.com/rstudio/cheatsheets/blob/master/data-visualization-2.1.pdf). 2.1.2 What is a “statistical graphic”? Wilkinson (2005) defines a grammar to describe the basic elements of a statistical graphic: “[…] a statistical graphic is a mapping from data to aesthetic attributes (colour, shape, size) of geometric objects (points, line, bars).” (Wickham, 2009) 2.1.3 Terminology Data: The data to visualize – consists of variables and observations. Geoms: Geometric objects which represent the data (points, lines, polygons, etc.). Mappings: Match variables with aesthetic attributes of the (geometric) objects. Scales: Mapping of the “data units” to “physical units” of the geometric objects (e.g. length, diameter or color); defines the legend. Coord: System of coordinates, mapping of the data to a two dimensional plain of the graphic; defines the axes and grid. Stats: Statistical transformation of the data (5 point summary, classification, etc.). Facetting: Division and illustration of data subsets, also known as “Trellis” images. 2.1.4 The Grammar of graphics … is … a formal guideline which describes the dependencies between all elements of a statistical graphic. isn’t … a manual which tells us which graphic should be created for a given question. a specification how a statistical graphic should look like. 2.1.5 About {ggplot2} ## Package: ggplot2 ## Version: 3.2.1 ## Title: Create Elegant Data Visualisations Using the Grammar of Graphics ## Depends: R (&gt;= 3.2) ## Imports: digest, grDevices, grid, gtable (&gt;= 0.1.1), lazyeval, MASS, mgcv, ## reshape2, rlang (&gt;= 0.3.0), scales (&gt;= 0.5.0), stats, tibble, ## viridisLite, withr (&gt;= 2.0.0) ## License: GPL-2 | file LICENSE ## URL: http://ggplot2.tidyverse.org, https://github.com/tidyverse/ggplot2 ## BugReports: https://github.com/tidyverse/ggplot2/issues ## Encoding: UTF-8 ## Author: Hadley Wickham [aut, cre], Winston Chang [aut], Lionel Henry [aut], ## Thomas Lin Pedersen [aut], Kohske Takahashi [aut], Claus Wilke [aut], ## Kara Woo [aut], Hiroaki Yutani [aut], RStudio [cph] ## Maintainer: Hadley Wickham &lt;hadley@rstudio.com&gt; ## ## -- File: 2.2 geom_* functions Click here to show setup code. library(tidyverse) geom_* functions are added to the main ggplot() call via the “+” operator and (usually) placed on a new line. A list of all available “geoms” can be found here: https://ggplot2.tidyverse.org/reference/#section-layer-geoms The most popular ones are geom_point() geom_histogram() geom_boxplot() geom_bar() The geom_* family can be divided into three parts: One variable plots geom_hist() geom_bar() etc. Two variable plots geom_point() geom_line() geom_boxplot() etc. Three variables plots geom_raster() geom_sf() geom_tile() etc. 2.2.1 Arguments ggplot(data, mapping = aes(), ...) + geom_XXX(mapping = NULL, data = NULL, stat, ...) geom_* functions have the same basic arguments as ggplot(). In addition, they come with more arguments specific to the respective “geom”. stat The stat parameter defines a statistical transformation: if set to &quot;identity&quot;: No transformation if set to boxplot: Boxplot transformation etc. position The same applies to the position argument. In the example below, points are not adjusted and just visualized where they appear in the data. In the case of boxplots, a special position arrangement function is used to arrange everything nicely: position_dodge2() (here denoted by position = &quot;dodge2&quot;). geom_point(mapping = NULL, data = NULL, stat = &quot;identity&quot;, position = &quot;identity&quot;, ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) geom_boxplot(mapping = NULL, data = NULL, stat = &quot;boxplot&quot;, position = &quot;dodge2&quot;, ..., outlier.colour = NULL, outlier.color = NULL, outlier.fill = NULL, outlier.shape = 19, outlier.size = 1.5, outlier.stroke = 0.5, outlier.alpha = NULL, notch = FALSE, notchwidth = 0.5, varwidth = FALSE, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) geom_boxplot() needs one variable to be of class character or factor (better) to initiate the grouping. class(mpg$class) ## [1] &quot;character&quot; ggplot(mpg, aes(x = class, y = displ)) + geom_boxplot() 2.2.2 Combining geoms Multiple geom_* functions can be used in one plot. A combination that is often used together is geom_point() and geom_smooth() ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth(method = &quot;lm&quot;) Unless specified differently in the geom_*() call, all geoms will use the same variables. 2.2.3 Summary The modular principle of ggplot2 enables: the combination of any geometric objects (geoms). a high flexibility and customizability An extensive description of all geometric objects can be found on the ggplot2 website https://ggplot2.tidyverse.org/reference/. Exercises https://krlmlr.github.io/vistransrep/2019-11-zhr/geoms.html 2.3 Two variable plots Click here to show setup code. library(tidyverse) “Two variable plots” can be split into sub-categories: Continuous X and Y Continuous X and discrete Y (and vice-versa) Discrete X and Y 2.3.1 Continuous X and Y ggplot(mpg, aes(x = cty, y = hwy)) + geom_point() 2.3.2 Discrete X and continuous Y ggplot(mpg, aes(x = class, y = hwy)) + geom_boxplot() 2.3.3 Discrete X and Y ggplot(mpg, aes(x = class, y = manufacturer)) + geom_jitter() 2.4 One variable plots Click here to show setup code. library(tidyverse) This type of plots visualizes ONE variable in a certain way. To do this in a 2D space, a statistical transformation of the variable is required for the missing axis. 2.4.1 Continuous variables Histogram: Most common way - grouping the variable into equal bins geom_density(), geom_freq(), geom_dotplot() and geom_area() are mainly doing the same as geom_hist() We supply only one variable to the mapping argument with the help of aes(). This one is automatically grouped into 30 bins. ggplot(mpg, aes(x = hwy)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with ## `binwidth`. ggplot(mpg, aes(x = hwy)) + geom_density() 2.4.2 Discrete variables For discrete data, there is actually only one visualization method - the bar plot. Note the difference of geom_bar() compared to geom_hist(). ggplot(mpg, aes(fl)) + geom_bar() Exercises browseURL(&quot;https://krlmlr.github.io/vistransrep/2019-11-zhr/scatter.html&quot;) 2.5 Colors and shape Click here to show setup code. library(tidyverse) 2.5.1 Static colors There are many ways to set a color for a specific geom. The simplest is to set all observations of a geom to a dedicated color, supplied as a character value. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point( color = &quot;blue&quot; ) 2.5.2 Dynamic colors Dynamic colors, which depend on a variable of the dataset, need to be passed within an aes() call. A direct specification like in the example above with color = &quot;blue&quot; only works for static colors. Good to know: While it is possible to include color = class directly in the aes() call of the ggplot() function, it is recommended to set it within the particular geom. This is for two reasons: When working with multiple geoms, you can use different mappings for each geom without any possibility of conflicts When reading the code, it becomes more clear which settings apply to which geoms Discrete Different colors can be mapped to the values of a variable by supplying a variable of the dataset. The class variable is discrete and leads to a discrete color scale. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point(aes(color = class)) Continuous The cty attribute is continuous, the color scale is adapted accordingly. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point(aes(color = cty)) 2.5.3 Shape One more degree of freedom is the shape of the symbols to be plotted. ggplot( data = mpg, mapping = aes( x = displ, y = hwy ) ) + geom_point(aes(shape = fl)) 2.5.4 Combining color and shape Color and shape can be combined. ggplot( data = mpg, mapping = aes( x = displ, y = hwy, ) ) + geom_point(aes(color = class, shape = drv)) And last but not least, the size of the plotted symbols can be linked to numeric values of the mapped variable. ggplot( data = mpg, mapping = aes( x = displ, y = hwy ) ) + geom_point(aes(size = cty)) You can mix different aesthetic mappings in order to produce a plot with densely packed information. However, be aware that adding too much information to a plot does not necessarily make it better. ggplot( data = mpg, mapping = aes( x = displ, y = hwy ) ) + geom_point(aes( color = class, size = cty )) 2.5.5 Transparency Semi-transparency is another way to better display your data when observations are overlapping. This is useful to get an impression of how many data points share the same coordinates. ggplot( data = mpg, mapping = aes( x = displ, y = hwy ) ) + geom_point(alpha = 0.2) 2.5.6 What can go wrong If you try to specify a color in the mapping-argument of the main ggplot() call, you will face an error since a mapping of a variable to an aesthetic is expected. try(print( ggplot( data = mpg, mapping = aes( x = displ, y = hwy, color = blue ) ) + geom_point() )) ## Error in FUN(X[[i]], ...) : object &#39;blue&#39; not found R treats objects without quotation marks in a special way, expecting them to be variables. Since blue is not a variable of mpg, this did not work. Use quotation marks if you mean a string, as opposed to a variable or object name. mpg ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 ## 2 audi a4 1.8 1999 4 manu… f 21 29 ## 3 audi a4 2 2008 4 manu… f 20 31 ## # … with 231 more rows, and 2 more variables: fl &lt;chr&gt;, ## # class &lt;chr&gt; &quot;mpg&quot; ## [1] &quot;mpg&quot; So what if we pass the color as a character variable? ggplot( data = mpg, mapping = aes( x = displ, y = hwy ) ) + geom_point(aes(color = &quot;blue&quot;)) At least there was no error, but now the constant value blue is mapped to the first default color of the color mapping, which happens to be red. We could have been fooled, if it had been blue. Recall, it is best to specify geom related mappings with the respective geom function. ggplot( data = mpg, mapping = aes( x = displ, y = hwy ) ) + geom_point( color = &quot;blue&quot; ) Exercises https://krlmlr.github.io/vistransrep/2019-11-zhr/scatter3.html 2.6 Labels Click here to show setup code. library(tidyverse) For character variables there is further way of integrating its value to a plot. geom_text() takes a label argument, which influences the plot in the following way. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_text(label = &quot;A&quot;) Let’s try to map this argument to a variable (here: drv) of our dataset in the mapping argument of ggplot(). ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_text(label = &quot;drv&quot;) Right, of course we need to pass the variable without quotation marks, otherwise it is interpreted as a (constant) character variable. When changing this, a vector with the values of the variable is passed on to geom_text(). This is one way of including the values of character variables in a plot. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_text(aes(label = drv)) When adding more than one geom()-function, multiple geometries are added to the plot. However, because geom_point() has no support for passing a label, we can only use this mapping in geom_text(). ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point() + geom_text(aes(label = drv)) Since this looks just slightly odd, let’s try to make it more apparent, what is happening. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point(color = &quot;blue&quot;) + geom_text(aes(label = drv), size = 10) 2.7 Themes Click here to show setup code. library(tidyverse) In this section we are looking at the use of visual themes to easily change the look and feel of a plot. We start with the introduction of the default theme – theme_grey() function. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point() + theme_grey() Change the default theme_grey() to a more traditional black-and-white theme: ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point() + theme_bw() Also in this scheme the color aesthetic works as it normally does. The black-and-whiteness only relates to the background. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point(aes(color = class)) + theme_bw() Calling the function theme() after a theme_...() call let’s you tweak certain aspects of the theme. Some plots work better with the legend at the bottom. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point(aes(color = class)) + theme_bw() + theme(legend.position = &quot;bottom&quot;) Mind that theme_...() functions overwrite all previous settings of theme(): ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point(aes(color = class)) + theme(legend.position = &quot;bottom&quot;) + theme_bw() The first argument of each theme_...() function is base_size, which refers to the font size of all elements in the plot. ggplot( data = mpg, mapping = aes(x = displ, y = hwy, color = class) ) + geom_point() + theme_bw(16) If we were asked to suggest themes, we’d go for ggplot2::theme_minimal() hrbrthemes::theme_ipsum() ggpubr::theme_pubr() Here is how ggpubr::theme_pubr() looks like. ggplot( data = mpg, mapping = aes(x = displ, y = hwy, color = class) ) + geom_point() + ggpubr::theme_pubr() Also from here onward we will use theme_pubr() as the default theme for plots. This can be done by setting 2.8 Scales Click here to show setup code. library(tidyverse) library(ggpubr) theme_set(theme_pubr()) In this section we want to spend some time getting to know how to customize the labels and scales of plots using {ggplot2}. We start with a pretty basic plot using the mpg-tibble which comes with the {tidyverse}. ggplot( data = mpg, mapping = aes(x = displ, y = hwy, color = class) ) + geom_point() 2.8.1 labs() With labs() you can label all sorts of aesthetics (axes, color mapping, …). Additionally you can set the title/subtitle and also add a caption and a tag. ggplot( data = mpg, mapping = aes(x = displ, y = hwy, color = class) ) + geom_point() + labs( x = &quot;Displacement&quot;, y = &quot;Highway mileage\\n[miles per gallon]&quot;, color = &quot;Car class&quot;, title = &quot;Highway mileages depending on displacement&quot;, subtitle = &quot;By car class&quot; ) 2.8.2 Axes There is a plethora of scale_...() functions available in {ggplot2}, which influence the axes. For example there is a function to change the scale of an axis to a logarithmic scale. ggplot( data = mpg, mapping = aes(x = displ, y = hwy, color = class) ) + geom_point() + scale_x_log10() Be careful: you can set the name of an axis in both the labs() function and the scale_...() functions. If you do both, only the name set in the latter will prevail. ggplot( data = mpg, mapping = aes(x = displ, y = hwy, color = class) ) + geom_point() + labs( x = &quot;Displacement&quot; ) + scale_x_log10(name = &quot;xxx&quot;) For more control over discrete and continuous axis labels, limits and breaks, the scale_&lt;axis name&gt;_&lt;variable type&gt; functions exist, e.g. scale_x_continuous(). These enable custom axis breaks and labels if the ones autogenerated from the data are not sufficient. ggplot(mpg, aes(displ, hwy)) + geom_point() + scale_x_continuous(limits = c(2, 6), breaks = c(2, 4, 6)) ## Warning: Removed 27 rows containing missing values ## (geom_point). Values not falling into the custom limits will be silently droppend including a warning message. 2.8.3 Color scale Another type scale_...()-type function relates to the color-aesthetic. These functions affect the palette that is used for the color mapping. By default, scale_color_hue() will be used for categorical variables. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point(aes(color = class)) + scale_color_hue() To change the color palette, pass a palette-function of your liking in the form of scale_color_&lt;name&gt; scale_fill_&lt;name&gt; Whether to use fill or color depends on what keyword has been used for applying the color. Points are colored by using the “color” keyword. So to change the palette for point coloring, one needs to use scale_color_&lt;name&gt;. A popular color palette is the viridis color palette. To specify that we are dealing with categorical values, we add a _d at the end which stands for “discrete”. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point(aes(color = class)) + scale_color_viridis_d() To take full control of the colors scale_color_manual() should be used. Here, color values (either as a string or in hex format) can be bound to a specific factor level. This is useful if certain levels come with implicit meanings of their color choice. Another helpful scenario is when there are more levels in the data than colors supported by the palette (most palettes support between 9-12 levels). ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point(aes(color = class)) + scale_color_manual(values = c( &quot;2seater&quot; = &quot;#000000&quot;, &quot;compact&quot; = &quot;#3355FF&quot;, &quot;midsize&quot; = &quot;#006400&quot;, &quot;minivan&quot; = &quot;#FF5522&quot;, &quot;pickup&quot; = &quot;#66FFFF&quot;, &quot;subcompact&quot; = &quot;#FF0000&quot;, &quot;suv&quot; = &quot;#FF55FF&quot; )) Review the {ggthemr} package for tools that help with establishing a “corporate design” for documents. install.packages(&quot;remotes&quot;) remotes::install_packages(&quot;cttobin/ggthemr&quot;) Exercises https://krlmlr.github.io/vistransrep/2019-11-zhr/scales.html 2.9 Export &amp; saving Click here to show setup code. library(tidyverse) The default way to export plots in {{ggplot2}} is by using ggsave(). It differs slightly from other “exporting” functions in R because it comes with some smart defaults: ggsave() is a convenient function for saving a plot. It defaults to saving the last plot that you displayed, using the size of the current graphics device. It also guesses the type of graphics device from the extension. ggplot(mtcars, aes(mpg, wt)) + geom_point() ggsave(&quot;mtcars.pdf&quot;) ## Saving 6.5 x 4 in image ggsave(&quot;mtcars.png&quot;) ## Saving 6.5 x 4 in image This might seem natural to you but is is not. Let’s compare base R and {{ggplot2}}. 2.9.1 Base R vs. {{ggplot2}} In base R one needs to open a specific graphic device first then create the plot and close the graphic device again. png(&quot;Plot.png&quot;) plot(mpg$displ, mpg$hwy) dev.off() ggplot(mpg, aes(disply, hwy)) + geom_point() ggsave(&quot;Plot.png&quot;) Base R plotting functions come with suboptimal defaults saving in pixels (differs on every monitors) saving as a square image no option to specify the DPI (dots per inch) 2.9.2 Storing the plot as an R object One of the major advantages of ggplot() is that you can save a plot as an R object and modify it later. This is not possible with base R plots. p &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point() p + geom_point(aes(color = class)) print(p) str(p) ## List of 9 ## $ data :Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 234 obs. of 11 variables: ## ..$ manufacturer: chr [1:234] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; ... ## ..$ model : chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ... ## ..$ displ : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ... ## ..$ year : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ... ## ..$ cyl : int [1:234] 4 4 4 4 6 6 6 4 4 4 ... ## ..$ trans : chr [1:234] &quot;auto(l5)&quot; &quot;manual(m5)&quot; &quot;manual(m6)&quot; &quot;auto(av)&quot; ... ## ..$ drv : chr [1:234] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ... ## ..$ cty : int [1:234] 18 21 20 21 16 18 18 18 16 20 ... ## ..$ hwy : int [1:234] 29 29 31 30 26 26 27 26 25 28 ... ## ..$ fl : chr [1:234] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; ... ## ..$ class : chr [1:234] &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; ... ## $ layers :List of 1 ## ..$ :Classes &#39;LayerInstance&#39;, &#39;Layer&#39;, &#39;ggproto&#39;, &#39;gg&#39; &lt;ggproto object: Class LayerInstance, Layer, gg&gt; ## aes_params: list ## compute_aesthetics: function ## compute_geom_1: function ## compute_geom_2: function ## compute_position: function ## compute_statistic: function ## data: waiver ## draw_geom: function ## finish_statistics: function ## geom: &lt;ggproto object: Class GeomPoint, Geom, gg&gt; ## aesthetics: function ## default_aes: uneval ## draw_group: function ## draw_key: function ## draw_layer: function ## draw_panel: function ## extra_params: na.rm ## handle_na: function ## non_missing_aes: size shape colour ## optional_aes: ## parameters: function ## required_aes: x y ## setup_data: function ## use_defaults: function ## super: &lt;ggproto object: Class Geom, gg&gt; ## geom_params: list ## inherit.aes: TRUE ## layer_data: function ## map_statistic: function ## mapping: NULL ## position: &lt;ggproto object: Class PositionIdentity, Position, gg&gt; ## compute_layer: function ## compute_panel: function ## required_aes: ## setup_data: function ## setup_params: function ## super: &lt;ggproto object: Class Position, gg&gt; ## print: function ## setup_layer: function ## show.legend: NA ## stat: &lt;ggproto object: Class StatIdentity, Stat, gg&gt; ## aesthetics: function ## compute_group: function ## compute_layer: function ## compute_panel: function ## default_aes: uneval ## extra_params: na.rm ## finish_layer: function ## non_missing_aes: ## parameters: function ## required_aes: ## retransform: TRUE ## setup_data: function ## setup_params: function ## super: &lt;ggproto object: Class Stat, gg&gt; ## stat_params: list ## super: &lt;ggproto object: Class Layer, gg&gt; ## $ scales :Classes &#39;ScalesList&#39;, &#39;ggproto&#39;, &#39;gg&#39; &lt;ggproto object: Class ScalesList, gg&gt; ## add: function ## clone: function ## find: function ## get_scales: function ## has_scale: function ## input: function ## n: function ## non_position_scales: function ## scales: list ## super: &lt;ggproto object: Class ScalesList, gg&gt; ## $ mapping :List of 2 ## ..$ x: language ~displ ## .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## ..$ y: language ~hwy ## .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## ..- attr(*, &quot;class&quot;)= chr &quot;uneval&quot; ## $ theme : list() ## $ coordinates:Classes &#39;CoordCartesian&#39;, &#39;Coord&#39;, &#39;ggproto&#39;, &#39;gg&#39; &lt;ggproto object: Class CoordCartesian, Coord, gg&gt; ## aspect: function ## backtransform_range: function ## clip: on ## default: TRUE ## distance: function ## expand: TRUE ## is_free: function ## is_linear: function ## labels: function ## limits: list ## modify_scales: function ## range: function ## render_axis_h: function ## render_axis_v: function ## render_bg: function ## render_fg: function ## setup_data: function ## setup_layout: function ## setup_panel_params: function ## setup_params: function ## transform: function ## super: &lt;ggproto object: Class CoordCartesian, Coord, gg&gt; ## $ facet :Classes &#39;FacetNull&#39;, &#39;Facet&#39;, &#39;ggproto&#39;, &#39;gg&#39; &lt;ggproto object: Class FacetNull, Facet, gg&gt; ## compute_layout: function ## draw_back: function ## draw_front: function ## draw_labels: function ## draw_panels: function ## finish_data: function ## init_scales: function ## map_data: function ## params: list ## setup_data: function ## setup_params: function ## shrink: TRUE ## train_scales: function ## vars: function ## super: &lt;ggproto object: Class FacetNull, Facet, gg&gt; ## $ plot_env :&lt;environment: R_GlobalEnv&gt; ## $ labels :List of 2 ## ..$ x: chr &quot;displ&quot; ## ..$ y: chr &quot;hwy&quot; ## - attr(*, &quot;class&quot;)= chr [1:2] &quot;gg&quot; &quot;ggplot&quot; 2.9.3 Best practices for exporting Some best practices: Use a reasonable high DPI. A value of “300” is ok in most cases. Save in “inches” and not in “pixels”. The latter always differs on screens with different resolutions (png() uses pixels by default.) Always specify a file name to ensure the right plot is chosen. Do not rely on the default behavior of ggsave() (even though it might seem convenient) which takes the last visualized plot. An alternative to ggsave() is cowplot::save_plot() which comes with sensible defaults for multi-plot arrangements. 2.10 Facetting Click here to show setup code. library(tidyverse) library(ggsci) library(ggpubr) theme_set(theme_pubr()) “Facetting” (or trellis plots, lattice plots) denotes an idea of dividing a graphic into sub-graphics based on the (categorical) values of one or more variables of a dataset. The variables used for faceting should be passed encapsulated in vars(). (Before {ggplot2} v3.0.0 the default was to use a formula notation (&lt;variable&gt; ~ &lt;variable&gt;) to specify the faceting variables.) facet_grid(facets = vars(&lt;variable&gt;), scales = &quot;fixed&quot;, ...) facet_wrap(rows = vars(&lt;variable&gt;), cols = vars(&lt;variable&gt;), scales = &quot;fixed&quot;, ...) facet: Variables given via vars() or formula with splitting variable. scales: Scale of the axes over the sub-graphics. The position of &lt;variable&gt; in facet_wrap() denotes on which axis the facets will appear: vars(&lt;variable&gt;) \\(\\rightarrow\\) y-axis vars(), vars(&lt;variable&gt;) \\(\\rightarrow\\) x-axis 2.10.1 facet_wrap() ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = fl)) + scale_color_nejm() + facet_grid(vars(), vars(year)) ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = fl)) + scale_color_nejm() + facet_grid(vars(year), vars()) Rather than visualizing a 2D-facet plot on x and y, there is also the option to combine both in one axis. (For this to work, the variables need to be of class factor). mpg %&gt;% mutate(manufacturer = as.factor(manufacturer)) %&gt;% mutate(year = as.factor(year)) %&gt;% ggplot(aes(displ, hwy)) + geom_point() + facet_wrap(vars(manufacturer:year)) This is usually a better setting than doubling the facet labels - but might also be up to personal preference. ggplot(mpg, aes(displ, hwy)) + geom_point() + facet_wrap(vars(manufacturer, year)) 2.10.2 facet_grid() While facet_wrap() tries to act smart and hide non-existing combinations of sub-plots, facet_grid() will create a full matrix of sub-plots for all possible combinations. Most of the time when using only one categorical variable, facet_wrap() does a good job and is preferred over facet_grid(). However, facet_grid might be preferred in the following cases: when faceting over &gt;= 2 variables when plots of empty combinations should be shown Let’s compare how facet_grid and facet_wrap differ for 2 grouping variables where not all combinations of those contain observations: ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + facet_grid(vars(year), vars(cyl)) ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + facet_wrap(vars(year, cyl)) 2.10.3 Scales By default, scales are fixed across each facet (scales = &quot;fixed&quot;). This means that all sub-plots should share the same axes. By setting this argument to either &quot;free_x&quot; or &quot;free_y&quot; one can specify that each each sub-plot should have its own scale. ggplot(mpg, aes(displ, hwy)) + geom_point() + facet_grid(vars(year), vars(cyl), scales = &quot;free_x&quot;) + theme_pubr(base_size = 7) This only makes sense if the ranges for each facet differ substantially (so not in this example!). This example is good to show the confusion that this setting might introduce. People usually expect to look at equal ranges across facets (unless there is a good reason for it not to) and differing scales make the plot more complicated. Keep in mind: Visualization should simplify data! 2.10.4 Renaming of facet labels A non-trivial change that is often applied to facet plots is the (re-)naming of the facet labels. Facet labels are automatically created based on the factor levels of the respective variable. However, sometimes the raw factor levels are not descriptive enough. In these cases, it makes sense to prefix the factor level values with the column name. This can be achieved by setting the labeller argument of facet_* to label_both. (An alternative would be to modify the underlying factor levels of the data so that these are descriptive right from the start.) ggplot(mpg, aes(displ, hwy)) + geom_point() + facet_grid(vars(), vars(cyl), labeller = label_both) Exercises https://krlmlr.github.io/vistransrep/2019-11-zhr/facet.html 2.11 Extensions A mass of R packages extending {ggplot2} exists. Many are listed at http://www.ggplot2-exts.org/gallery/. Here is a selected list of our favorite {ggplot2} extensions including some use examples. {ggsci}: https://nanx.me/ggsci/ {ggforce}: https://ggforce.data-imaginist.com/ {patchwork}: https://patchwork.data-imaginist.com/ {gganimate}: https://gganimate.com/ {plotly}: https://plotly-r.com/ {ggtext}: https://github.com/clauswilke/ggtext {ggiraph}: http://davidgohel.github.io/ggiraph {ggbeeswarm}: https://github.com/eclarke/ggbeeswarm {esquisse}: https://dreamrs.github.io/esquisse ( {ggstatsplot}: https://indrajeetpatil.github.io/ggstatsplot ) ( {ggedit}: https://github.com/metrumresearchgroup/ggedit ) ( {lindia}: https://github.com/yeukyul/lindia ) Click here to show setup code. library(tidyverse) library(ggsci) library(ggpubr) library(patchwork) library(ggpmisc) library(ggiraph) library(ggbeeswarm) library(gganimate) library(plotly) library(ggrepel) library(ggforce) library(ggpubr) library(gapminder) theme_set(theme_pubr()) 2.11.1 {ggsci} p1 &lt;- ggplot(mpg, aes(manufacturer)) + geom_bar(aes(fill = fl)) p2 &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = fl)) library(&quot;patchwork&quot;) p1_npg &lt;- p1 + ggsci::scale_fill_npg() p2_nejm &lt;- p2 + ggsci::scale_color_nejm() p1_npg + p2_nejm 2.11.2 {ggforce} ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) + geom_point() + ggforce::facet_zoom(x = Species == &quot;versicolor&quot;) 2.11.3 {gganimate} ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, colour = country)) + geom_point(alpha = 0.7, show.legend = FALSE) + scale_colour_manual(values = country_colors) + scale_size(range = c(2, 12)) + scale_x_log10() + facet_wrap(~continent) + labs(title = &#39;Year: {frame_time}&#39;, x = &#39;GDP per capita&#39;, y = &#39;life expectancy&#39;) + gganimate::transition_time(year) + ease_aes(&#39;linear&#39;) ## Warning: No renderer available. Please install the gifski, av, ## or magick package to create animated output ## NULL 2.11.4 {plotly} p &lt;- ggplot(diamonds, aes(x = log(carat), y = log(price))) + geom_hex(bins = 100) ggplotly(p) plot_ly(z = ~volcano, type = &quot;surface&quot;) 2.11.5 {ggtext} df &lt;- data.frame( label = c( &quot;Some text **in bold.**&quot;, &quot;Linebreaks&lt;br&gt;Linebreaks&lt;br&gt;Linebreaks&quot;, &quot;*x*&lt;sup&gt;2&lt;/sup&gt; + 5*x* + *C*&lt;sub&gt;*i*&lt;/sub&gt;&quot;, &quot;Some &lt;span style=&#39;color:blue&#39;&gt;blue text **in bold.**&lt;/span&gt;&lt;br&gt;And *italics text.*&lt;br&gt; And some &lt;span style=&#39;font-size:18pt; color:black&#39;&gt;large&lt;/span&gt; text.&quot; ), x = c(.2, .1, .5, .9), y = c(.8, .4, .1, .5), hjust = c(0.5, 0, 0, 1), vjust = c(0.5, 1, 0, 0.5), angle = c(0, 0, 45, -45), color = c(&quot;black&quot;, &quot;blue&quot;, &quot;black&quot;, &quot;red&quot;), fill = c(&quot;cornsilk&quot;, &quot;white&quot;, &quot;lightblue1&quot;, &quot;white&quot;) ) ggplot(df) + aes( x, y, label = label, angle = angle, color = color, hjust = hjust, vjust = vjust ) + ggtext::geom_richtext( fill = NA, label.color = NA, # remove background and outline label.padding = grid::unit(rep(0, 4), &quot;pt&quot;) # remove padding ) + geom_point(color = &quot;black&quot;, size = 2) + scale_color_nejm() + xlim(0, 1) + ylim(0, 1) + theme_pubr() 2.11.6 {ggrepel} no_repel &lt;- ggplot(mtcars, aes(wt, mpg)) + geom_text(label = rownames(mtcars), size = 3) + geom_point(color = &quot;red&quot;) + theme_pubr() with_repel &lt;- ggplot(mtcars, aes(wt, mpg)) + ggrepel::geom_text_repel(label = rownames(mtcars), size = 3) + geom_point(color = &quot;red&quot;) + theme_pubr() no_repel + with_repel 2.11.7 {ggiraph} gg_point &lt;- ggplot(mtcars, aes(wt, mpg)) + ggiraph::geom_point_interactive(tooltip = rownames(mtcars)) girafe(ggobj = gg_point) 2.11.8 {ggbeeswarm} normal_overplotting &lt;- ggplot(mpg, aes(class, hwy)) + geom_point(alpha = 0.4) + theme_pubr() ggbeeswarm &lt;- ggplot(mpg, aes(class, hwy)) + ggbeeswarm::geom_beeswarm(size = 1.1) + theme_pubr() library(patchwork) normal_overplotting + ggbeeswarm 2.11.9 {ggpmisc} p &lt;- ggplot(mpg, aes(factor(cyl), hwy)) + stat_summary(geom = &quot;col&quot;, fun.y = mean, width = 2 / 3, aes(fill = factor(cyl))) + labs(x = &quot;Number of cylinders&quot;, y = NULL, title = &quot;Means&quot;) + scale_fill_nejm(guide = FALSE) data.tb &lt;- tibble( x = 7, y = 44, plot = list(p + theme_pubr(8)) ) ggplot(mpg, aes(displ, hwy)) + ggpmisc::geom_plot(data = data.tb, aes(x, y, label = plot)) + geom_point(aes(colour = factor(cyl))) + scale_colour_nejm() + labs( colour = &quot;Engine cylinders\\n(number)&quot; ) + theme_pubr() 2.11.10 {esquisse} esquisse::esquisser(mpg) "],
["transformation.html", "3 Transformation 3.1 Package: {conflicted} 3.2 Filtering 3.3 Sorting 3.4 The pipe 3.5 Pick columns 3.6 Create new columns 3.7 Summarize data 3.8 Summary-plots", " 3 Transformation Using a consistent grammar of data manipulation. library(tidyverse) library(nycflights13) conflicted::conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) conflicted::conflict_prefer(&quot;lag&quot;, &quot;dplyr&quot;) This chapter discusses data transformation with the dplyr package. One table: filter() select() arrange() mutate() summarise() Grouped operations group_by() ungroup() Joins xxx_join() 3.1 Package: {conflicted} Click here to show setup code. library(tidyverse) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package This section is dedicated to show you the basic building blocks (i.e. functions) of data analysis in R within the {tidyverse}. The package providing these is {dplyr}. Before starting, we would like to mention the package {conflicted}, which when loaded, will help detecting functions of the same name from different packages (an error is thrown in case of such situations). It furthermore helps to resolve these situations, by allowing you to choose, the function of which package you prefer (conflicted::conflict_prefer()). You can see an example in the setup code. 3.2 Filtering Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package During this lecture we will be working with data from the package {nycflights13}, which contains flights in the year 2013 with their departure in New York City (airports: JFK, LGA or EWR) to destinations in the United States, Puerto Rico, and the American Virgin Islands. flights ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## # … with 3.368e+05 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; ?flights The function dplyr::filter() helps you to reduce your dataset to the observations (rows) of interest. The filter condition can use any of the dataset’s variables and needs to be a logical expression. flights %&gt;% filter(dep_time &lt; 600) ## # A tibble: 8,730 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## # … with 8,727 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; The following building blocks are frequently used in a filter: Operators: ==, !=, &lt;, &gt;, &lt;=, &gt;= month == 3 # careful: two = month &gt;= 10 carrier != &quot;UA&quot; # careful: &lt;&gt; doesn&#39;t work arr_time &lt; dep_time near() near(sin(pi), 0) between(), %in% between(hour, 8, 12) month %in% c(12, 1, 2) Negation: ! Use parentheses () to indicate precedence str_detect() for strings Missing values can be detected with is.na(): flights %&gt;% filter(is.na(dep_time)) ## # A tibble: 8,255 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 NA 1630 NA NA ## 2 2013 1 1 NA 1935 NA NA ## 3 2013 1 1 NA 1500 NA NA ## # … with 8,252 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; flights %&gt;% filter(is.na(dep_time - arr_time)) ## # A tibble: 8,713 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 2016 1930 46 NA ## 2 2013 1 1 NA 1630 NA NA ## 3 2013 1 1 NA 1935 NA NA ## # … with 8,710 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; Use &amp; or multiple filters to return only rows that match both criteria: flights %&gt;% filter(dep_time &lt; 600 &amp; arr_time &gt; 2200) ## # A tibble: 0 x 19 ## # … with 19 variables: year &lt;int&gt;, month &lt;int&gt;, day &lt;int&gt;, ## # dep_time &lt;int&gt;, sched_dep_time &lt;int&gt;, dep_delay &lt;dbl&gt;, ## # arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, ## # dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; flights %&gt;% filter(dep_time &gt;= 700 &amp; arr_time &lt; 800) ## # A tibble: 10,654 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 1929 1920 9 3 ## 2 2013 1 1 1939 1840 59 29 ## 3 2013 1 1 2058 2100 -2 8 ## # … with 1.065e+04 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; flights %&gt;% filter(dep_time &gt;= 700) %&gt;% filter(arr_time &lt; 800) ## # A tibble: 10,654 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 1929 1920 9 3 ## 2 2013 1 1 1939 1840 59 29 ## 3 2013 1 1 2058 2100 -2 8 ## # … with 1.065e+04 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; Use | to return all rows that match either criterion or both: flights %&gt;% filter(dep_time &lt; 600 | arr_time &gt; 2200) ## # A tibble: 40,879 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## # … with 4.088e+04 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; Exercises https://krlmlr.github.io/vistransrep/2019-11-zhr/filtering.html https://krlmlr.github.io/vistransrep/2019-11-zhr/filter-combine.html 3.3 Sorting Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package The function dplyr::arrange() sorts the rows of the dataset according to the values of the variable(s) you are providing. flights %&gt;% arrange(dep_time) ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 13 1 2249 72 108 ## 2 2013 1 31 1 2100 181 124 ## 3 2013 11 13 1 2359 2 442 ## # … with 3.368e+05 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; When providing multiple variables as arguments for ... (the ellipsis), the dataset is first sorted accorcing to the values of the first variable. Wherever these values occur more than once, another sorting takes place within those groups, according to the second variable you provided. The same rule applies for every further variable you add to arrange(). flights %&gt;% arrange(dep_time, dep_delay) ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 11 13 1 2359 2 442 ## 2 2013 12 16 1 2359 2 447 ## 3 2013 12 20 1 2359 2 430 ## # … with 3.368e+05 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; You can combine filter() and arrange(). flights %&gt;% filter(dep_time &lt; 600) %&gt;% filter(month &gt;= 10) %&gt;% arrange(dep_time, dep_delay) %&gt;% view() ## # A tibble: 1,894 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 11 13 1 2359 2 442 ## 2 2013 12 16 1 2359 2 447 ## 3 2013 12 20 1 2359 2 430 ## # … with 1,891 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; You can use arrange() with arbitrary expressions. flights %&gt;% filter(month == 4) %&gt;% filter(day == 1) %&gt;% arrange(is.na(dep_time)) %&gt;% view() ## # A tibble: 970 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 4 1 454 500 -6 636 ## 2 2013 4 1 509 515 -6 743 ## 3 2013 4 1 526 530 -4 812 ## # … with 967 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; The reason for the result you just saw in the view of the filtered dataset is, that the binary result of the expression (TRUE, FALSE) is sorted FALSE first (lexicographically). Let’s give it a twist: flights %&gt;% filter(month == 4) %&gt;% filter(day == 1) %&gt;% arrange(!is.na(dep_time)) %&gt;% view() ## # A tibble: 970 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 4 1 NA 1125 NA NA ## 2 2013 4 1 NA 1545 NA NA ## 3 2013 4 1 NA 850 NA NA ## # … with 967 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; Sorting the dataset according to which flights arrived earliest on April 1, 2013: flights %&gt;% filter(month == 4) %&gt;% filter(day == 1) %&gt;% arrange(arr_time) %&gt;% view() ## # A tibble: 970 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 4 1 2243 2245 -2 6 ## 2 2013 4 1 2056 1925 91 8 ## 3 2013 4 1 2216 2100 76 9 ## # … with 967 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; Invert the sorting by either… flights %&gt;% filter(month == 4) %&gt;% filter(day == 1) %&gt;% arrange(-arr_time) %&gt;% view() ## # A tibble: 970 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 4 1 2027 2032 -5 2358 ## 2 2013 4 1 2151 1930 141 2358 ## 3 2013 4 1 2252 2245 7 2358 ## # … with 967 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; … or: flights %&gt;% filter(month == 4) %&gt;% filter(day == 1) %&gt;% arrange(desc(arr_time)) %&gt;% view() ## # A tibble: 970 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 4 1 2027 2032 -5 2358 ## 2 2013 4 1 2151 1930 141 2358 ## 3 2013 4 1 2252 2245 7 2358 ## # … with 967 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; You can mix sorting in an ascending and a descending manner: flights %&gt;% filter(month == 4) %&gt;% filter(day == 1) %&gt;% arrange(dep_time, desc(arr_time)) %&gt;% view() ## # A tibble: 970 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 4 1 454 500 -6 636 ## 2 2013 4 1 509 515 -6 743 ## 3 2013 4 1 526 530 -4 812 ## # … with 967 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; Exercises https://krlmlr.github.io/vistransrep/2019-11-zhr/arrange.html 3.4 The pipe Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package We already heavily used it today, but what exactly are the characteristics of %&gt;%, better known as “the pipe”? early_flights &lt;- flights %&gt;% filter(dep_time &lt; 600) The above is just another way of writing: early_flights &lt;- filter(flights, dep_time &lt; 600) The manual describes this operator in detail: ?&quot;%&gt;%&quot; With the pipe, code can be read in a natural way, from left to right. The following snippet extracts all early flights from October till December, ordered by departure time and then departure delay and displays it. Note how the reading corresponds to the code. flights %&gt;% filter(dep_time &lt; 600) %&gt;% filter(month &gt;= 10) %&gt;% arrange(dep_time, dep_delay) %&gt;% view() ## # A tibble: 1,894 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 11 13 1 2359 2 442 ## 2 2013 12 16 1 2359 2 447 ## 3 2013 12 20 1 2359 2 430 ## # … with 1,891 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; This is possible, because all transformation verbs (filter(), arrange(), view()) accept the main input (a tibble) as the first argument and also return a tibble. The following three codes are equivalent, but are more difficult to write, to read and to maintain. Naming is hard. Trying to give each intermediate result a name is exhausting. Introducing an additional step in this sequence of operations is prone to errors. early_flights &lt;- filter(flights, dep_time &lt; 600) early_flights_oct_dec &lt;- filter(early_flights, month &gt;= 10) early_flights_oct_dec_sorted &lt;- arrange(early_flights_oct_dec, dep_time, dep_delay) view(early_flights_oct_dec_sorted) ## # A tibble: 1,894 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 11 13 1 2359 2 442 ## 2 2013 12 16 1 2359 2 447 ## 3 2013 12 20 1 2359 2 430 ## # … with 1,891 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; We can keep using the same variable, e.g. x, to avoid naming. This adds noise compared to the pipe. x &lt;- flights x &lt;- filter(x, dep_time &lt; 600) x &lt;- filter(x, month &gt;= 10) x &lt;- arrange(x, dep_time, dep_delay) view(x) ## # A tibble: 1,894 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 11 13 1 2359 2 442 ## 2 2013 12 16 1 2359 2 447 ## 3 2013 12 20 1 2359 2 430 ## # … with 1,891 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; We can avoid intermediate variables. This disconnects the verbs from their arguments and is very difficult to read. view( arrange( filter( filter( flights, dep_time &lt; 600 ), month &gt;= 10 ), dep_time, dep_delay ) ) ## # A tibble: 1,894 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 11 13 1 2359 2 442 ## 2 2013 12 16 1 2359 2 447 ## 3 2013 12 20 1 2359 2 430 ## # … with 1,891 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; 3.4.1 Further advantages When working on a code chunk consisting of subsequent transformations connected by pipes, it can be useful to end the pipeline with either I or view(). flights %&gt;% filter(dep_time &lt; 600) %&gt;% filter(month &gt;= 10) %&gt;% I ## # A tibble: 1,894 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## * &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 10 1 447 500 -13 614 ## 2 2013 10 1 522 517 5 735 ## 3 2013 10 1 536 545 -9 809 ## # … with 1,891 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; ##arrange(dep_time, dep_delay) %&gt;% ##view() Once the chunk does what you expect it to do, do not forget to remove the I or view() call. try( arrange(dep_time, dep_delay) %&gt;% view() ) ## Error in arrange(dep_time, dep_delay) : object &#39;dep_time&#39; not found To rearrange rows, you can use the shortcut Alt + Cursor up/down. In a piped expression, no further editing is necessary! Exercises https://krlmlr.github.io/vistransrep/2019-11-zhr/pipe.html 3.5 Pick columns Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package With dplyr::select() you can (de-)select and/or rename columns of your dataset. The basic operation is like in the following examples: flights %&gt;% select(year, month, day) ## # A tibble: 336,776 x 3 ## year month day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 ## 2 2013 1 1 ## 3 2013 1 1 ## # … with 3.368e+05 more rows flights %&gt;% select(-year) ## # A tibble: 336,776 x 18 ## month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 1 517 515 2 830 ## 2 1 1 533 529 4 850 ## 3 1 1 542 540 2 923 ## # … with 3.368e+05 more rows, and 12 more variables: ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; Renaming works by addressing an existing column on the right hand side of an equality sign and providing the new name of the column on its left hand side. flights %&gt;% select( year, month, day, departure_delay = dep_delay, arrival_delay = arr_delay ) ## # A tibble: 336,776 x 5 ## year month day departure_delay arrival_delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 2 11 ## 2 2013 1 1 4 20 ## 3 2013 1 1 2 33 ## # … with 3.368e+05 more rows With backticks, it is possible, but not advised, to use arbitrary characters (including spaces) in column names: flights_with_spaces &lt;- flights %&gt;% select( year, month, day, `Departure delay` = dep_delay, `Arrival delay` = arr_delay ) %&gt;% filter( `Arrival delay` &lt; 0 ) Address them in the same way, if the dataset already has such variables: flights_with_spaces %&gt;% select( year, month, day, dep_delay = `Departure delay`, arr_delay = `Arrival delay` ) ## # A tibble: 188,933 x 5 ## year month day dep_delay arr_delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 -1 -18 ## 2 2013 1 1 -6 -25 ## 3 2013 1 1 -3 -14 ## # … with 1.889e+05 more rows The {janitor} package helps fixing issues with colum names automatically. Select helpers allow selecting multiple related columns conveniently: flights %&gt;% select(origin, dest, ends_with(&quot;_time&quot;)) ## # A tibble: 336,776 x 7 ## origin dest dep_time sched_dep_time arr_time sched_arr_time ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 EWR IAH 517 515 830 819 ## 2 LGA IAH 533 529 850 830 ## 3 JFK MIA 542 540 923 850 ## # … with 3.368e+05 more rows, and 1 more variable: ## # air_time &lt;dbl&gt; Exercises https://krlmlr.github.io/vistransrep/2019-11-zhr/select-rename.html 3.6 Create new columns Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package conflict_prefer(&quot;lag&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::lag[39m over any other package With dplyr::mutate() you can add new columns to a table, e.g. making use of the already existing variables. This is another building block added to the toolset. How much faster than the scheduled time did the pilots manage to fly: flights %&gt;% mutate(recovery = dep_delay - arr_delay) %&gt;% select(dep_delay, arr_delay, recovery) ## # A tibble: 336,776 x 3 ## dep_delay arr_delay recovery ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 11 -9 ## 2 4 20 -16 ## 3 2 33 -31 ## # … with 3.368e+05 more rows Conceptually, the expression that defines the new variable is evaluated for each row. The following constructs are often applied inside mutate(): Arithmetic: +, -, *, /, ^, %%, %/% dep_delay - arr_delay dep_time %/% 100 dep_time %% 100 dep_delay - mean(dep_delay) # Deviation from mean Real functions, see ?base::Math and ?dplyr::lead: Rounding: floor(), ceiling(), round() Sign: abs(), sign() Transform: sqrt(), log(), log2(), exp() Trigonometric: sin() etc. Recoding: if_else(), case_when(), recode() All filtering functions for a new logical column str_replace() for string columns Functions that process values from other rows: Cumulative: cumsum() etc. Lead and lag: lead(), lag() Ranking: row_number(), min_rank(), ntile() Work with the newly created variables just like with the original ones: flights %&gt;% mutate(recovery = dep_delay - arr_delay) %&gt;% select(dep_delay, arr_delay, recovery) %&gt;% arrange(recovery) ## # A tibble: 336,776 x 3 ## dep_delay arr_delay recovery ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -2 194 -196 ## 2 -2 179 -181 ## 3 180 345 -165 ## # … with 3.368e+05 more rows A mutate() never changes a dataset. To make a computation persistent, store the entire result as a new dataset variable. try( flights %&gt;% select(recovery) ) ## Error in .f(.x[[i]], ...) : object &#39;recovery&#39; not found recovery_data &lt;- flights %&gt;% mutate(recovery = dep_delay - arr_delay) %&gt;% select(dep_delay, arr_delay, recovery) %&gt;% arrange(recovery) recovery_data ## # A tibble: 336,776 x 3 ## dep_delay arr_delay recovery ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -2 194 -196 ## 2 -2 179 -181 ## 3 180 345 -165 ## # … with 3.368e+05 more rows Let’s look at a single airplane: flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% select(year, month, day, dep_time, arr_time) %&gt;% view() ## # A tibble: 111 x 5 ## year month day dep_time arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 830 ## 2 2013 1 8 1435 1717 ## 3 2013 1 9 717 812 ## # … with 108 more rows Adding the departure time of the next flight to the current row, respectively, using mutate() with lead(): flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% select(year, month, day, dep_time, arr_time) %&gt;% mutate(lead_dep_time = lead(dep_time)) %&gt;% view() ## # A tibble: 111 x 6 ## year month day dep_time arr_time lead_dep_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 830 1435 ## 2 2013 1 8 1435 1717 717 ## 3 2013 1 9 717 812 1143 ## # … with 108 more rows The opposite effect to lead() can be realized using lag(): flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% select(year, month, day, dep_time, arr_time) %&gt;% mutate(lag_arr_time = lag(arr_time)) %&gt;% view() ## # A tibble: 111 x 6 ## year month day dep_time arr_time lag_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 830 NA ## 2 2013 1 8 1435 1717 830 ## 3 2013 1 9 717 812 1717 ## # … with 108 more rows There is even a use-case for this in our little example. How long does it take for the airplane to return to NYC with each flight out? flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% select(year, month, day, time_hour) %&gt;% mutate(lag_time_hour = lag(time_hour)) %&gt;% mutate(ground_time = time_hour - lag_time_hour) %&gt;% view() ## # A tibble: 111 x 6 ## year month day time_hour lag_time_hour ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dttm&gt; &lt;dttm&gt; ## 1 2013 1 1 2013-01-01 05:00:00 NA ## 2 2013 1 8 2013-01-08 14:00:00 2013-01-01 05:00:00 ## 3 2013 1 9 2013-01-09 07:00:00 2013-01-08 14:00:00 ## # … with 108 more rows, and 1 more variable: ## # ground_time &lt;drtn&gt; A frequently used workflow is creating a helper variable at some point in the pipeline and then dropping it later on: flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% select(year, month, day, dep_time, arr_time) %&gt;% mutate(lag_arr_time = lag(arr_time)) %&gt;% mutate(ground_time = dep_time - lag_arr_time) %&gt;% select(-lag_arr_time) ## # A tibble: 111 x 6 ## year month day dep_time arr_time ground_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 830 NA ## 2 2013 1 8 1435 1717 605 ## 3 2013 1 9 717 812 -1000 ## # … with 108 more rows Let’s work some more with the flight data of our special plane. The total air time of a plane up to and including a given flight can be calculated with cumsum(): flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% mutate(cum_air_time = cumsum(air_time)) %&gt;% select(air_time, cum_air_time) %&gt;% view() ## # A tibble: 111 x 2 ## air_time cum_air_time ## &lt;dbl&gt; &lt;dbl&gt; ## 1 227 227 ## 2 150 377 ## 3 39 416 ## # … with 108 more rows Creating a “flag” variable with mutate() allows selecting if a flight was on time or not: flights %&gt;% mutate(delayed = if_else(arr_delay &gt; 0, &quot;delayed&quot;, &quot;on time&quot;)) %&gt;% select(arr_delay, delayed) ## # A tibble: 336,776 x 2 ## arr_delay delayed ## &lt;dbl&gt; &lt;chr&gt; ## 1 11 delayed ## 2 20 delayed ## 3 33 delayed ## # … with 3.368e+05 more rows Shorter, but less verbose: flights %&gt;% mutate(delayed = (arr_delay &gt; 0)) %&gt;% select(arr_delay, delayed) ## # A tibble: 336,776 x 2 ## arr_delay delayed ## &lt;dbl&gt; &lt;lgl&gt; ## 1 11 TRUE ## 2 20 TRUE ## 3 33 TRUE ## # … with 3.368e+05 more rows A flag can be passed on to filter() directly: flights %&gt;% mutate(delayed = arr_delay &gt; 0) %&gt;% select(arr_delay, delayed) %&gt;% filter(delayed) ## # A tibble: 133,004 x 2 ## arr_delay delayed ## &lt;dbl&gt; &lt;lgl&gt; ## 1 11 TRUE ## 2 20 TRUE ## 3 33 TRUE ## # … with 1.33e+05 more rows Use negation for inverse filtering, and store in a dataset variable for reuse: on_time_flights &lt;- flights %&gt;% mutate(delayed = (arr_delay &gt; 0)) %&gt;% select(arr_delay, delayed) %&gt;% filter(!delayed) on_time_flights ## # A tibble: 194,342 x 2 ## arr_delay delayed ## &lt;dbl&gt; &lt;lgl&gt; ## 1 -18 FALSE ## 2 -25 FALSE ## 3 -14 FALSE ## # … with 1.943e+05 more rows Exercises https://krlmlr.github.io/vistransrep/2019-11-zhr/mutate.html 3.7 Summarize data Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package conflict_prefer(&quot;lag&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::lag[39m over any other package Often we want to draw just conclusions from larger datasets by gaining insight by using statistical (or other) methods for summarizing – and thus drastically reducing – the data: How much time did all planes spend in the air? flights %&gt;% select(air_time) %&gt;% mutate(total_air_time = sum(air_time, na.rm = TRUE)) ## # A tibble: 336,776 x 2 ## air_time total_air_time ## &lt;dbl&gt; &lt;dbl&gt; ## 1 227 49326610 ## 2 227 49326610 ## 3 160 49326610 ## # … with 3.368e+05 more rows The mutate() call adds a new variable with the same value across all rows. To reduce the result to a single row, use summarize(): flights %&gt;% summarize(total_air_time = sum(air_time, na.rm = TRUE)) ## # A tibble: 1 x 1 ## total_air_time ## &lt;dbl&gt; ## 1 49326610 The following functions compute summary values: sum(), prod() na.rm = TRUE mean(), median() sd(), IQR(), mad() min(), quantile(0.75), max() sum() and mean() for logical variables: r mean(is.na(arr_time)) Ranking n() first(), last(), nth() Simple counts can be computed with n() inside summarize(): flights %&gt;% summarize(n = n()) ## # A tibble: 1 x 1 ## n ## &lt;int&gt; ## 1 336776 A variety of aggregate functions is supported: flights %&gt;% summarize(median = median(air_time, na.rm = TRUE)) ## # A tibble: 1 x 1 ## median ## &lt;dbl&gt; ## 1 129 It’s possible to produce two different summarizations at once: flights %&gt;% summarize( n = n(), mean_air_time = mean(air_time, na.rm = TRUE), median_air_time = median(air_time, na.rm = TRUE) ) ## # A tibble: 1 x 3 ## n mean_air_time median_air_time ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 336776 151. 129 The summarize() verb gains its full power in grouped operations. Surround with group_by() and ungroup() to compute summaries in groups defined by common values in one or more columns. In the next example, the same summary is computed separately for each origin airport. Figure 3.1: © Allison Horst flights %&gt;% group_by(origin) %&gt;% summarize( n = n(), mean_air_time = mean(air_time, na.rm = TRUE), median_air_time = median(air_time, na.rm = TRUE) ) %&gt;% ungroup() ## # A tibble: 3 x 4 ## origin n mean_air_time median_air_time ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 EWR 120835 153. 130 ## 2 JFK 111279 178. 149 ## 3 LGA 104662 118. 115 Conceptually this corresponds to the following sequence of operations: Split the dataset into groups defined by the values of the origin column. Each group has the same value in origin. Apply the same summary for each group. In this case, the size, mean air time, and median air time is computed across all flights for each group. Combine the results into one data frame. The grouping variables and the results are bound together for further analysis. More often than not, the question “how do I iterate over each group and do …” can be reprased as “what summary value do I want to compute for each group”. Recognizing this takes a bit of practice but is worth the effort, because the analysis code becomes shorter and more robust and often runs faster. Groups can be defined over multiple columns as well. The next example splits the data into one group for each day. flights %&gt;% group_by(year, month, day) %&gt;% summarize( n = n(), mean_air_time = mean(air_time, na.rm = TRUE), median_air_time = median(air_time, na.rm = TRUE) ) %&gt;% ungroup() ## # A tibble: 365 x 6 ## year month day n mean_air_time median_air_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 842 170. 149 ## 2 2013 1 2 943 162. 148 ## 3 2013 1 3 914 157. 148 ## # … with 362 more rows For quick exploration, the names of the new columns can be omitted: flights %&gt;% group_by(year, month, day) %&gt;% summarize( n(), mean(air_time, na.rm = TRUE), median(air_time, na.rm = TRUE) ) %&gt;% ungroup() ## # A tibble: 365 x 6 ## year month day `n()` `mean(air_time, n… `median(air_time… ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 842 170. 149 ## 2 2013 1 2 943 162. 148 ## 3 2013 1 3 914 157. 148 ## # … with 362 more rows The n() function computes a simple count, and is one of the most frequently used summary functions. The count() function provides a convenient alternative. flights %&gt;% count(year, month, day) ## # A tibble: 365 x 4 ## year month day n ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 842 ## 2 2013 1 2 943 ## 3 2013 1 3 914 ## # … with 362 more rows Exercises https://krlmlr.github.io/vistransrep/2019-11-zhr/summarize.html https://krlmlr.github.io/vistransrep/2019-11-zhr/summarize-mult.html 3.8 Summary-plots Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package conflict_prefer(&quot;lag&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::lag[39m over any other package Potentially surprisingly, mutate() can also work with the results of a ggplot() call. Let’s approach this step by step. Here is a basic barplot of flights$carrier: flights %&gt;% ggplot(aes(x = carrier)) + geom_bar() Same with one facet per month: flights %&gt;% ggplot(aes(x = carrier)) + geom_bar() + facet_wrap(~month) We can extract a function that takes any data and produces a barplot of the variable carrier: plot_fun &lt;- function(data) { data %&gt;% ggplot(aes(x = carrier)) + geom_bar() } plot_fun(flights) The result of ggplot() is first and foremost an object. Only when R tries to display it on the console a method is triggered, which causes it to show the graph in the “Viewer”. Therefore, we can use the group_by – summarize() – ungroup() pattern to produce one plot per group and store it in a new column: plot_df &lt;- flights %&gt;% group_by(month) %&gt;% summarize( plot = list(plot_fun(tibble(carrier))) ) %&gt;% ungroup() plot_df ## # A tibble: 12 x 2 ## month plot ## &lt;int&gt; &lt;list&gt; ## 1 1 &lt;gg&gt; ## 2 2 &lt;gg&gt; ## 3 3 &lt;gg&gt; ## # … with 9 more rows When using dplyr::pull() (this function “extracts” a variable from a data.frame and returns it as a normal vector), each of the plots will be subsequently displayed in your “Viewer”. plot_df %&gt;% pull() ## [[1]] ## ## [[2]] ## ## [[3]] ## ## [[4]] ## ## [[5]] ## ## [[6]] ## ## [[7]] ## ## [[8]] ## ## [[9]] ## ## [[10]] ## ## [[11]] ## ## [[12]] Use the left arrow to click through the different plots. "],
["import.html", "4 Import 4.1 Import single files 4.2 Import many files", " 4 Import Ingesting data. This chapter discusses data import with RStudio, with the help of the readr, readxl, and rio packages. 4.1 Import single files Click here to show setup code. library(tidyverse) library(readr) The RStudio IDE offers a convenient way to import files in various common formats, including CSV and Excel. The “File / Import Dataset / From …” menus provide access to import assistants that: open a file for preview, allow tweaking import options, generate R code that you can copy-paste into your scripts for further reuse. The assistant is run once for each dataset, from then only the generated code is required to import the data in a consistent way. This is an example of auto-generated code for importing a dataset from the data/ directory. example1 &lt;- read_delim( &quot;data/example1.csv&quot;, &quot;;&quot;, escape_double = FALSE, trim_ws = TRUE ) ## Parsed with column specification: ## cols( ## col1 = [32mcol_double()[39m, ## col2 = [31mcol_character()[39m, ## col3 = [31mcol_character()[39m ## ) After importing, use view() to display the ingested dataset. view(example1) ## # A tibble: 2 x 3 ## col1 col2 col3 ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 a X ## 2 2.5 b Y Exercises https://krlmlr.github.io/vistransrep/2019-11-zhr/import.html, task 1 and 2 4.2 Import many files Click here to show setup code. library(tidyverse) library(nycflights13) library(here) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package Occasionally, a dataset is split across many files with a very similar format. The data/ directory contains several Excel files with the .xlsx extension with tables of nearly identical format. files &lt;- dir(path = here(&quot;data&quot;), pattern = &quot;[.]xlsx$&quot;, full.names = TRUE) files ## [1] &quot;/home/travis/build/krlmlr/vistransrep/book/data/example6a.xlsx&quot; ## [2] &quot;/home/travis/build/krlmlr/vistransrep/book/data/example6b.xlsx&quot; ## [3] &quot;/home/travis/build/krlmlr/vistransrep/book/data/example6c.xlsx&quot; An easy way to import all files at once is the rio::import_list() function from the {rio} package. files %&gt;% rio::import_list(setclass = class(tibble()), rbind = TRUE) ## # A tibble: 6 x 5 ## id col1 col2 col3 `_file` ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 1 a X /home/travis/build/krlmlr/vistransr… ## 2 1 2.5 b Y /home/travis/build/krlmlr/vistransr… ## 3 2 1.5 c Z /home/travis/build/krlmlr/vistransr… ## 4 2 2 d W /home/travis/build/krlmlr/vistransr… ## 5 3 4 g J /home/travis/build/krlmlr/vistransr… ## 6 3 3.5 f H /home/travis/build/krlmlr/vistransr… If some files need manipulation before the data can be bound together, {rio} also offers a way to import them as a “named list”. list_of_tables &lt;- rio::import_list(files, setclass = class(tibble())) list_of_tables ## $example6a ## # A tibble: 2 x 4 ## id col1 col2 col3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 1 a X ## 2 1 2.5 b Y ## ## $example6b ## # A tibble: 2 x 4 ## id col1 col2 col3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 1.5 c Z ## 2 2 2 d W ## ## $example6c ## # A tibble: 2 x 4 ## id col1 col2 col3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 3 4 g J ## 2 3 3.5 f H The data can be accessed individually for each input file. list_of_tables$example6b ## # A tibble: 2 x 4 ## id col1 col2 col3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 1.5 c Z ## 2 2 2 d W If a tweak is necessary, the data can be overwritten as needed. try( list_of_tables$example6b &lt;- list_of_tables$example6b %&gt;% mutate(...) %&gt;% select(...) ) ## Error in function_list[[i]](value) : &#39;...&#39; used in an incorrect context The bind_rows() function combines these components into a single dataset again. all_tables &lt;- bind_rows(list_of_tables, .id = &quot;path&quot;) all_tables ## # A tibble: 6 x 5 ## path id col1 col2 col3 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 example6a 1 1 a X ## 2 example6a 1 2.5 b Y ## 3 example6b 2 1.5 c Z ## 4 example6b 2 2 d W ## 5 example6c 3 4 g J ## 6 example6c 3 3.5 f H When done, use filter() to access a single dataset. all_tables %&gt;% filter(path == &quot;example6b&quot;) %&gt;% summarize(mean(col1), first(col2)) ## # A tibble: 1 x 2 ## `mean(col1)` `first(col2)` ## &lt;dbl&gt; &lt;chr&gt; ## 1 1.75 c For performing an analysis across the entire dataset, per input file, use group_by(): all_tables %&gt;% group_by(path) %&gt;% summarize(mean(col1), first(col2)) %&gt;% ungroup() ## # A tibble: 3 x 3 ## path `mean(col1)` `first(col2)` ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 example6a 1.75 a ## 2 example6b 1.75 c ## 3 example6c 3.75 g Finally, map_dfr() offers a way to import files with more control. The details are out of scope here. files %&gt;% map_dfr(~ readxl::read_excel(.)) ## # A tibble: 6 x 4 ## id col1 col2 col3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 1 a X ## 2 1 2.5 b Y ## 3 2 1.5 c Z ## 4 2 2 d W ## 5 3 4 g J ## 6 3 3.5 f H Exercises https://krlmlr.github.io/vistransrep/2019-11-zhr/import.html, task 3 and 4 "],
["tidying.html", "5 Tidying 5.1 Pivoting 5.2 Separating and uniting", " 5 Tidying Rows, columns, cells. This chapter discusses pivoting and data tidying with the help of the tidyr package. 5.1 Pivoting Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package conflict_prefer(&quot;lag&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::lag[39m over any other package Pivoting describes operations that help rearrange data in different ways. The following two tables contain the same data arranged differently. table1 ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 table2 ## # A tibble: 12 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## # … with 9 more rows Both tables contain country and year column that describe the source of the measurements. The “wider” version, table1, contains two columns that hold the number of cases (of a disease) and the population for the corresponding country in the corresponding year. In the “longer” version, table2, the number of cases and the population are stored in the same count column, with the type column defining the measurement. Somewhat counter-intuitively, “longer-form” data is often better suited for analyzing data. “Wider-form” data makes better use of screen space, but may be more difficult to work with. The following example computes the maximum number of cases and population for each country. For the wider form, this requires repeating the same expression for all columns. This may work with two columns but becomes tedious once more measurements are added. table1 %&gt;% group_by(country) %&gt;% summarize( max_cases = max(cases), max_population = max(population) ) %&gt;% ungroup() ## # A tibble: 3 x 3 ## country max_cases max_population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 2666 20595360 ## 2 Brazil 80488 174504898 ## 3 China 213766 1280428583 The _at family of functions helps iterating over columns, but all columns still need to be enumerated. (Specifying ranges of columns is rather brittle.) table1 %&gt;% group_by(country) %&gt;% summarize_at( vars(cases, population), max ) %&gt;% ungroup() ## # A tibble: 3 x 3 ## country cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 2666 20595360 ## 2 Brazil 80488 174504898 ## 3 China 213766 1280428583 If the data is in the “longer” form, it is sufficient to include type in the grouping variables. The same code works for arbitrary number of measurements. table2 %&gt;% group_by(country, type) %&gt;% summarize( max = max(count) ) %&gt;% ungroup() ## # A tibble: 6 x 3 ## country type max ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan cases 2666 ## 2 Afghanistan population 20595360 ## 3 Brazil cases 80488 ## 4 Brazil population 174504898 ## 5 China cases 213766 ## 6 China population 1280428583 The following examples give a gentle introduction into pivoting. 5.1.1 Convert to longer form The pivot_longer() function takes a “wider-form” dataset and converts it to an equivalent dataset with more rows. table1 ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 table1 %&gt;% pivot_longer(-c(country, year)) ## # A tibble: 12 x 4 ## country year name value ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## # … with 9 more rows The -c(...) notation indicates that all column except country and year are to be transformed into longer form. The column names become the contents of the new name column, the values are available in the value column. Your turn: The result of this operation isn’t strictly equivalent to table2. What is missing? Alternatively, the names_to and values_to arguments allow specifying the names of the new columns. try( table1 %&gt;% pivot_longer(-c(country, year)) %&gt;% select(....., everything()) ) ## Error in .f(.x[[i]], ...) : object &#39;.....&#39; not found table1 %&gt;% pivot_longer( -c(country, year), names_to = &quot;type&quot;, values_to = &quot;count&quot; ) ## # A tibble: 12 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## # … with 9 more rows 5.1.2 Convert to wider form The pivot_wider() form does the inverse: it creates a dataset with fewer rows. If the name and value columns are named differently, these columns can be provided via the names_from and values_from arguments. table2 ## # A tibble: 12 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## # … with 9 more rows table2 %&gt;% pivot_wider(names_from = type, values_from = count) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Your turn: pivot_wider() expects columns name and value by default. What do we need to do to get rid of names_from and values_from? try( table2 %&gt;% select(......, everything()) %&gt;% pivot_wider() ) ## Error in .f(.x[[i]], ...) : object &#39;......&#39; not found 5.1.3 Use cases Data in “longer” form usually works better for plotting the values side by side, e.g. by assigning the type of value to an aesthetic. Recall that each row in the data produces one geometric object in the corresponding layer. For a bar chart that shows cases and population side by side, mapped to the y aesthetic, the “longer” form is more natural. table2 form requires only one layer, the fill color is determined automatically, the legend is created automatically table1 requires two layers, manual assignment of fill color, and manual creation of legend (not shown) table2 %&gt;% ggplot() + geom_col(aes(country, count, fill = type), position = &quot;dodge&quot;) + facet_wrap(~year) + scale_y_log10() table1 %&gt;% ggplot() + geom_col(aes(country, population), position = &quot;dodge&quot;, fill = &quot;blue&quot;) + geom_col(aes(country, cases), position = &quot;dodge&quot;, fill = &quot;red&quot;) + facet_wrap(~year) + scale_y_log10() On the other hand, iIf only a single measurement needs to be plotted, the “wider” form is easier to work with. table1 only requires selecting the correct column table2 requires a filter() table1 %&gt;% ggplot() + geom_col(aes(country, cases)) + facet_wrap(~year) table2 %&gt;% filter(type == &quot;cases&quot;) %&gt;% ggplot() + geom_col(aes(country, count)) + facet_wrap(~year) The “wider” form is also the only way to map different measures to different aesthetics, e.g. to correlate values. table1 %&gt;% ggplot() + geom_point(aes(cases, population, color = factor(year), shape = country)) + scale_x_log10() + scale_y_log10() 5.1.4 Combining vertically A different view on the same data is given in the two tables table4a and table4b. table4a ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 table4b ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 19987071 20595360 ## 2 Brazil 172006362 174504898 ## 3 China 1272915272 1280428583 The bind_rows() function combines these two parts into a single table. The .id = &quot;type&quot; setting ensures that the input datasets gain different tags in the new type column. table4 &lt;- bind_rows( cases = table4a, population = table4b, .id = &quot;type&quot; ) table4 ## # A tibble: 6 x 4 ## type country `1999` `2000` ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 cases Afghanistan 745 2666 ## 2 cases Brazil 37737 80488 ## 3 cases China 212258 213766 ## 4 population Afghanistan 19987071 20595360 ## 5 population Brazil 172006362 174504898 ## 6 population China 1272915272 1280428583 Your turn: As before, pivot_longer() helps converting the results into something similar to table2. The result isn’t quite the same yet, can you spot the difference? try( table4 %&gt;% ...(c(.....)) ) ## Error in ...(., c(.....)) : could not find function &quot;...&quot; 5.1.5 Tidy data From “R for data science”: In a tidy dataset, each variable must have its own column. each observation must have its own row. each value must have its own cell. Tidy data The next two sections show examples of datasets that violate these principles. 5.1.6 The Anscombe dataset This is a dataset where principal statistical summaries (means, standard deviations, intercept and slope after regression) are identical across four subgroups but the layout of the data differs vastly. anscombe ## x1 x2 x3 x4 y1 y2 y3 y4 ## 1 10 10 10 8 8.04 9.14 7.46 6.58 ## 2 8 8 8 8 6.95 8.14 6.77 5.76 ## [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 9 rows ] anscombe %&gt;% as_tibble() ## # A tibble: 11 x 8 ## x1 x2 x3 x4 y1 y2 y3 y4 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10 10 10 8 8.04 9.14 7.46 6.58 ## 2 8 8 8 8 6.95 8.14 6.77 5.76 ## 3 13 13 13 8 7.58 8.74 12.7 7.71 ## # … with 8 more rows Working with this data in original form is rather tedious. anscombe %&gt;% as_tibble() %&gt;% summarize_all(list(~ mean(.), ~ sd(.))) ## # A tibble: 1 x 16 ## x1_mean x2_mean x3_mean x4_mean y1_mean y2_mean y3_mean ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 9 9 9 9 7.50 7.50 7.5 ## # … with 9 more variables: y4_mean &lt;dbl&gt;, x1_sd &lt;dbl&gt;, ## # x2_sd &lt;dbl&gt;, x3_sd &lt;dbl&gt;, x4_sd &lt;dbl&gt;, y1_sd &lt;dbl&gt;, ## # y2_sd &lt;dbl&gt;, y3_sd &lt;dbl&gt;, y4_sd &lt;dbl&gt; lm(y1 ~ x1, anscombe) ## ## Call: ## lm(formula = y1 ~ x1, data = anscombe) ## ## Coefficients: ## (Intercept) x1 ## 3.0001 0.5001 lm(y2 ~ x2, anscombe) ## ## Call: ## lm(formula = y2 ~ x2, data = anscombe) ## ## Coefficients: ## (Intercept) x2 ## 3.001 0.500 lm(y3 ~ x3, anscombe) ## ## Call: ## lm(formula = y3 ~ x3, data = anscombe) ## ## Coefficients: ## (Intercept) x3 ## 3.0025 0.4997 lm(y4 ~ x4, anscombe) ## ## Call: ## lm(formula = y4 ~ x4, data = anscombe) ## ## Coefficients: ## (Intercept) x4 ## 3.0017 0.4999 try( ggplot(anscombe) + ... ) ## Error in try(ggplot(anscombe) + ...) : &#39;...&#39; used in an incorrect context Your turn: Which principles of tidy data does the anscombe dataset violate? Many operations become much more natural when the data is in longer form. anscombe_longer &lt;- anscombe %&gt;% mutate(id = row_number()) %&gt;% pivot_longer( -id, names_pattern = &quot;(.)(.)&quot;, names_to = c(&quot;.value&quot;, &quot;measurement&quot;) ) %&gt;% arrange(measurement, id) anscombe_longer %&gt;% group_by(measurement) %&gt;% summarize_at(vars(x, y), list(~ mean(.), ~sd(.))) %&gt;% ungroup() ## # A tibble: 4 x 5 ## measurement x_mean y_mean x_sd y_sd ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 9 7.50 3.32 2.03 ## 2 2 9 7.50 3.32 2.03 ## 3 3 9 7.5 3.32 2.03 ## 4 4 9 7.50 3.32 2.03 anscombe_longer %&gt;% group_by(measurement) %&gt;% summarize(model = list(lm(y ~ x, .))) %&gt;% ungroup() %&gt;% pull() ## [[1]] ## ## Call: ## lm(formula = y ~ x, data = .) ## ## Coefficients: ## (Intercept) x ## 3.0013 0.4999 ## ## ## [[2]] ## ## Call: ## lm(formula = y ~ x, data = .) ## ## Coefficients: ## (Intercept) x ## 3.0013 0.4999 ## ## ## [[3]] ## ## Call: ## lm(formula = y ~ x, data = .) ## ## Coefficients: ## (Intercept) x ## 3.0013 0.4999 ## ## ## [[4]] ## ## Call: ## lm(formula = y ~ x, data = .) ## ## Coefficients: ## (Intercept) x ## 3.0013 0.4999 anscombe_longer %&gt;% ggplot(aes(x = x, y = y)) + geom_point() + facet_wrap(vars(measurement)) 5.1.7 WHO data The following example shows a case that violates the first two rules of tidy data: WHO data arranged for optimal use of screen space. The column names define, in addition to the measurement type new_sp, new_sn, new_ep and newrel, the age and sex stratum of the corresponding measurements. One single pivot_longer() call transforms the data into a longer-form version with four measurement columns and one row for each age/sex stratum. The names_pattern is a regular expression that defines what part of the column name is stored where. (Regular expressions are a powerful tool for parsing text data, out of scope for this lecture but very much worth looking into.) The names_to sequence defines, for each () group in names_pattern, if the data encoded in the column name is stored in a new column or if it is kept as column name. who %&gt;% view() ## # A tibble: 7,240 x 60 ## country iso2 iso3 year new_sp_m014 new_sp_m1524 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghan… AF AFG 1980 NA NA ## 2 Afghan… AF AFG 1981 NA NA ## 3 Afghan… AF AFG 1982 NA NA ## # … with 7,237 more rows, and 54 more variables: ## # new_sp_m2534 &lt;int&gt;, new_sp_m3544 &lt;int&gt;, ## # new_sp_m4554 &lt;int&gt;, new_sp_m5564 &lt;int&gt;, new_sp_m65 &lt;int&gt;, ## # new_sp_f014 &lt;int&gt;, new_sp_f1524 &lt;int&gt;, ## # new_sp_f2534 &lt;int&gt;, new_sp_f3544 &lt;int&gt;, ## # new_sp_f4554 &lt;int&gt;, new_sp_f5564 &lt;int&gt;, new_sp_f65 &lt;int&gt;, ## # new_sn_m014 &lt;int&gt;, new_sn_m1524 &lt;int&gt;, ## # new_sn_m2534 &lt;int&gt;, new_sn_m3544 &lt;int&gt;, ## # new_sn_m4554 &lt;int&gt;, new_sn_m5564 &lt;int&gt;, new_sn_m65 &lt;int&gt;, ## # new_sn_f014 &lt;int&gt;, new_sn_f1524 &lt;int&gt;, ## # new_sn_f2534 &lt;int&gt;, new_sn_f3544 &lt;int&gt;, ## # new_sn_f4554 &lt;int&gt;, new_sn_f5564 &lt;int&gt;, new_sn_f65 &lt;int&gt;, ## # new_ep_m014 &lt;int&gt;, new_ep_m1524 &lt;int&gt;, ## # new_ep_m2534 &lt;int&gt;, new_ep_m3544 &lt;int&gt;, ## # new_ep_m4554 &lt;int&gt;, new_ep_m5564 &lt;int&gt;, new_ep_m65 &lt;int&gt;, ## # new_ep_f014 &lt;int&gt;, new_ep_f1524 &lt;int&gt;, ## # new_ep_f2534 &lt;int&gt;, new_ep_f3544 &lt;int&gt;, ## # new_ep_f4554 &lt;int&gt;, new_ep_f5564 &lt;int&gt;, new_ep_f65 &lt;int&gt;, ## # newrel_m014 &lt;int&gt;, newrel_m1524 &lt;int&gt;, ## # newrel_m2534 &lt;int&gt;, newrel_m3544 &lt;int&gt;, ## # newrel_m4554 &lt;int&gt;, newrel_m5564 &lt;int&gt;, newrel_m65 &lt;int&gt;, ## # newrel_f014 &lt;int&gt;, newrel_f1524 &lt;int&gt;, ## # newrel_f2534 &lt;int&gt;, newrel_f3544 &lt;int&gt;, ## # newrel_f4554 &lt;int&gt;, newrel_f5564 &lt;int&gt;, newrel_f65 &lt;int&gt; who_longer &lt;- who %&gt;% pivot_longer( -(country:year), names_pattern = &quot;([a-z_]+)_(.)([0-9]+)&quot;, names_to = c(&quot;.value&quot;, &quot;sex&quot;, &quot;age&quot;) ) who_longer ## # A tibble: 101,360 x 10 ## country iso2 iso3 year sex age new_sp new_sn new_ep ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghan… AF AFG 1980 m 014 NA NA NA ## 2 Afghan… AF AFG 1980 m 1524 NA NA NA ## 3 Afghan… AF AFG 1980 m 2534 NA NA NA ## # … with 1.014e+05 more rows, and 1 more variable: ## # newrel &lt;int&gt; who_longer %&gt;% count(sex, age) ## # A tibble: 14 x 3 ## sex age n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 f 014 7240 ## 2 f 1524 7240 ## 3 f 2534 7240 ## # … with 11 more rows 5.1.8 Formatting tables for presentation Wide tables make better use of screen or paper space, and should be used when presenting tables that summarize across multiple dimensions. For this, ftable() is the better tool. table2 %&gt;% xtabs(count ~ ., .) %&gt;% ftable() ## type cases population ## country year ## Afghanistan 1999 745 19987071 ## 2000 2666 20595360 ## Brazil 1999 37737 172006362 ## 2000 80488 174504898 ## China 1999 212258 1272915272 ## 2000 213766 1280428583 These can be converted to HTML for inclusion in reports, e.g. with memisc::format_html(). table2_html &lt;- table2 %&gt;% xtabs(count ~ ., .) %&gt;% ftable(col.vars = c(&quot;year&quot;, &quot;type&quot;)) %&gt;% memisc::format_html() cat(table2_html) year: 1999 2000 country type: cases population cases population Afghanistan 745 19987071 2666 20595360 Brazil 37737 172006362 80488 174504898 China 212258 1272915272 213766 1280428583 The {gt} package is a modern approach to present tables for formatting. 5.2 Separating and uniting Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package conflict_prefer(&quot;lag&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::lag[39m over any other package The table3 table violates the third principle of tidy data: each cell contains two values. table3 ## # A tibble: 6 x 3 ## country year rate ## * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 The separate() verb offers a convenient way to deal with this situation, including automatic type conversion. table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;)) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;), sep = &quot;/&quot;, convert = TRUE) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 The inverse is offered by unite(). The data in table5 stores year data in two columns. table5 ## # A tibble: 6 x 4 ## country century year rate ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 table5 %&gt;% unite(&quot;year&quot;, c(century, year)) ## # A tibble: 6 x 3 ## country year rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19_99 745/19987071 ## 2 Afghanistan 20_00 2666/20595360 ## 3 Brazil 19_99 37737/172006362 ## 4 Brazil 20_00 80488/174504898 ## 5 China 19_99 212258/1272915272 ## 6 China 20_00 213766/1280428583 The result needs a few tweaks to finally resemble table3. table5 %&gt;% unite(&quot;year&quot;, c(century, year), sep = &quot;&quot;) ## # A tibble: 6 x 3 ## country year rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 table5 %&gt;% unite(&quot;year&quot;, c(century, year), sep = &quot;&quot;) %&gt;% mutate(year = as.numeric(year)) ## # A tibble: 6 x 3 ## country year rate ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 See the help for further details. ?separate ?unite 5.2.1 Parsing numbers thousand_separator &lt;- tribble( ~num, &quot;1&#39;000.00&quot;, &quot;2&#39;000&#39;000.00&quot; ) thousand_separator ## # A tibble: 2 x 1 ## num ## &lt;chr&gt; ## 1 1'000.00 ## 2 2'000'000.00 thousand_separator %&gt;% separate(num, into = c(&quot;num&quot;)) ## Warning: Expected 1 pieces. Additional pieces discarded in 2 ## rows [1, 2]. ## # A tibble: 2 x 1 ## num ## &lt;chr&gt; ## 1 1 ## 2 2 thousand_separator %&gt;% mutate(num = str_replace_all(num, &quot;[^-0-9.]&quot;, &quot;&quot;)) %&gt;% mutate(num = as.numeric(num)) ## # A tibble: 2 x 1 ## num ## &lt;dbl&gt; ## 1 1000 ## 2 2000000 "],
["reporting.html", "6 Reporting 6.1 Overview 6.2 The YAML header 6.3 Literate programming in R 6.4 Shiny: Interactive visualizations", " 6 Reporting After the successful processing and visualization of the data, the results need to be reported. This can be done best in a “literate programming” fashion as provided by R Markdown. Using R Markdown, one is able to combine R code (and its results) with text (written in markdown) to create professional looking reports in various output formats (Word, PDF, HTML). Both interactive and static documents can be created. This gallery (maintained by RStudio) gives a first overview of how documents created using R Markdown can look like. 6.1 Overview File Format: .Rmd (R Markdown) New document (in RStudio): File -&gt; New File -&gt; R Markdown/R Notebook. LaTeX Math is supported via Mathjax: $y=\\frac{(x - \\mu)}{(max - min)}$ \\(y=\\frac{(x - \\mu)}{(max - min)}\\) Any file with the .Rmd file extension is an “R Markdown document”. RMD’s consist code and text (written in markdown syntax) which need to be compiled into a high-level output format. Possible output formats are: HTML PDF Word Powerpoint Which output format should be used is specified in the “YAML header” of the R Markdown document. 6.2 The YAML header In the YAML (Yet Another Markup Language) header users can specify metadata which denote the final appearance of the document. Each output format has different settings. Fortunately, most settings apply to all formats. The YAML header starts and ends with three dashes: ---. The output field is mandatory. --- title: &quot;&lt;title&gt;&quot; author: &quot;&lt;author&gt;&quot; date: &quot;2019-11-29&quot; output: rmarkdown::html_document: toc: yes number_sections: yes fig_caption: yes css: ../custom.css bibliography: lib.bib biblio-style: apalike --- Valid options for each output format can usually be looked up in the help page of the specific output format. For the default output format html_document the R Markdown - The definitive guide book is a good reference. An R Markdown cheatsheet also exists. 6.3 Literate programming in R Packages {rmarkdown} and {knitr} are the base of literate programming in R. RMD’s documents can be compiled by clicking the “knit” button in RStudio (the name relates to the {{knitr}} package) via the command line by calling rmarkdown::render() Behind the scenes the {rmarkdown} package first converts the .Rmd file to .md (markdown). Then pandoc, which is a universal markdown converter library, converts the .md file to the chosen output format. 6.3.1 R Markdown packages The following packages are built upon {rmarkdown} and simplify special purposes. bookdown: Mainly used for writing books but can also be used for reports (formats html_document2, git_book, pdf_book, etc.). thesisdown: A package for thesis writing. Provides ready-to-go templates for different types and simplifies advanced LaTeX usage. rmdformats, pinp : Different templates for literate programming documents. xaringan: For HTML presentations via remark.js. blogdown: For creating websites. Example: https://pat-s.me rticles: For scientific paper writing in R. 6.3.2 Code chunks in R Markdown To insert code into an R Markdown document, one needs to add a so called “code chunk”. ```{&lt;language&gt;} ``` This tells the document that everything within the three backticks should be interpreted as code using the given language. Code can be shown/hidden, evaluation can be prevented on demand, results can be cached, etc. See https://yihui.org/knitr/options/ for a full list of supported options 6.3.3 R Notebooks R Notebooks are a special form of the html_document. To use it, specify html_notebook as the “output” type in the YAML header. This output format was created by RStudio as an alternative to html_document. Differences compared to html_document: Code output is shown inside the editor and not in the console (can be changed) Instant preview of the output document without having to get all the code in the document running. The results from the last successful code execution will be used (if there was one). Link in the HTML doc to download the source .Rmd file Option to toggle on/off code chunks for the whole document Output file extension is named .nb.html 6.3.4 Workflow R Markdown documents are most often used for reporting of results created in an Rscript. This enables a seamless integration of data processing tasks into the subsequent reporting. Reporting often splits up into different formats: Talks using presentation slides (xaringan, ioslides, Slidy, Beamer, Powerpoint) written reports (Word, PDF), possibly using LaTeX input R objects (containing results) can directly be used in the reports to present the results (data, plots). If the complete workflow of an analysis has been set up in R, changes at certain stages of the workflow (e.g. incoming data) can easily be integrated. This is the point where packages like drake, workflowr and rrtools jump in to simplify reproducible workflows in R. A widely used concept is to start a project following the structure of an R package. This helps due to a consistent directory structure of R scripts and R Markdown documents documented custom functions simplified integration into workflow packages like {drake} and friends. R “research packages” can be installed locally like any other R package and simplify usage and sharing among colleagues. 6.4 Shiny: Interactive visualizations Javascript based R ecosystem which provides options for rich visualizations. The shiny gallery from RStudio gives a good overview what can be done using shiny. "],
["appendix-best-practices.html", "7 Appendix: Best practices 7.1 DESCRIPTION 7.2 R 7.3 roxygen2 7.4 testthat", " 7 Appendix: Best practices R code is often organized in packages that can be installed from centralized repositories such as CRAN or GitHub. If you are new to writing R packages, this course cannot give a complete introduction into packages. It is still useful to embrace some very few concepts of R packages to gain access to a vast toolbox and also organize your code in a standardized way familiar to other users. With the first steps in place, the road to your first R package may become less steep. Create a DESCRIPTION file to declare dependencies and allow easy reloading of the functions you define Store your functions in .R files in the R/ directory in your project Scripts that you execute live in script/ or a similar directory Use roxygen2 to document your functions close to the source Write tests for your functions, e.g. with testthat See R packages for a more comprehensive treatment. 7.1 DESCRIPTION Create and open a new RStudio project. Then, create a DESCRIPTION file with usethis::use_description(): # install.packages(&quot;usethis&quot;) usethis::use_description() Double-check success: # install.packages(&quot;devtools&quot;) devtools::load_all() Declare that your project requires the tidyverse and the here package: usethis::use_package(&quot;here&quot;) # Currently doesn&#39;t work, add manually # https://github.com/r-lib/usethis/issues/760 # usethis::use_package(&quot;tidyverse&quot;) 7.2 R With a DESCRIPTION file defined, create a new .R file and save it in the R/ directory. (Create this directory if it does not exist.) Create a function in this file, save the file: hi &lt;- function(text = &quot;Hello, world!&quot;) { print(text) invisible(text) } Do not source the file. Restart R (with Ctrl + Shift + F10 in RStudio). Run devtools::load_all() again, you can use the shortcut Ctrl + Shift + L or Cmd + Shift + L in RStudio. Check that you can run hi() in the console: hi() ## [1] &quot;Hello, world!&quot; hi(&quot;Wow!&quot;) ## [1] &quot;Wow!&quot; Edit the function: hi &lt;- function(text = &quot;Wow!&quot;) { print(text) invisible(text) } Save the file, but do not source it. Run devtools::load_all() again, you can use the shortcut Ctrl + Shift + L or Cmd + Shift + L in RStudio. Check that the new implementation of hi() is active: hi() ## [1] &quot;Wow!&quot; All functions that are required for your project are stored in this directory. Do not store executable scripts, use a script/ directory. 7.3 roxygen2 The following intuitive annotation syntax is a standard way to create documentation for your functions: #&#39; Print a welcome message #&#39; #&#39; This function prints &quot;Wow!&quot;, or a custom text, on the console. #&#39; #&#39; @param text The text to print, &quot;Wow!&quot; by default. #&#39; #&#39; @return The `text` argument, invisibly. #&#39; #&#39; @examples #&#39; hi() #&#39; hi(&quot;Hello!&quot;) hi &lt;- function(text = &quot;Wow!&quot;) { print(text) invisible(text) } This annotation can be rendered to a nicely looking HTML page with the roxygen2 and pkgdown packages. All you need to do is provide (and maintain) it. 7.4 testthat Automated tests make sure that the functions you write today continue working tomorrow. Create your first test with usethis::use_test(): # install.packages(&quot;testthat&quot;) usethis::use_test(&quot;hi&quot;) The file tests/testthat/test-hi.R is created, with the following contents: test_that(&quot;multiplication works&quot;, { expect_equal(2 * 2, 4) }) Replace this predefined text with a test that makes more sense for us: test_that(&quot;hi() works&quot;, { expect_output(hi(), &quot;Wow&quot;) expect_output(hi(&quot;Hello&quot;), &quot;Hello&quot;) }) Run the new test with devtools::test(), you can use the shortcut Ctrl + Shift + T or Cmd + Shift + T in RStudio. Check that the test actually detects failures by modifying the implementation of hi() and rerunning the test: hi &lt;- function(text = &quot;Oops!&quot;) { print(text) invisible(text) } Run the new test with devtools::test(), you can use the shortcut Ctrl + Shift + T or Cmd + Shift + T in RStudio. One test should be failing now. "],
["references.html", "References", " References R for data science: https://r4ds.had.co.nz/ Row oriented workflows: https://github.com/jennybc/row-oriented-workflows#readme What they forgot to teach you: https://whattheyforgot.org/ Advanced R: http://adv-r.had.co.nz/ Tidy evaluation: https://tidyeval.tidyverse.org/ R packages: http://r-pkgs.had.co.nz/ roxygen2: https://roxygen2.r-lib.org/ How R searches and finds stuff: http://blog.obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/ Parallel processing with a purrr-like interface: https://davisvaughan.github.io/furrr/ Recursive lists to use in teaching and examples: https://github.com/jennybc/repurrrsive Tidyverse principles: https://principles.tidyverse.org/ "]
]
