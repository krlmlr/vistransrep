```{r 23-remove-all, include = FALSE}
rm(list = ls())
```


## Sort rows: `dplyr::arrange()`

<details><summary>*Click here to show setup code.*</summary>
```{r include = FALSE}
### Sort rows: `dplyr::arrange()`

```
```{r 23-setup-23-arrange-r}
library(tidyverse)
library(nycflights13)

library(conflicted)
conflict_prefer("filter", "dplyr")
view <- I
```
</details>


*Note: In all of today's scripts, the function `tibble::view()` is redefined.
It normally let's you browse through a dataset in a newly opened window.
For our purposes, working with markdown, we are replacing `view()` with `I()`, which makes sure that what comes in also comes out.*

The function `dplyr::arrange()` sorts the rows of the dataset according to the values of the variable(s) you are providing.

```{r include = FALSE}
# simple arrange
```
```{r 23-simple-arrange}
flights %>%
  arrange(dep_time)
```

When providing multiple variables as arguments in the `...` parameter (AKA ellipsis), the dataset is first sorted accorcing to the values of the first variable.
Wherever these values occur more than once, another sorting takes place within those groups, according to the second variable you provided.
The same rule applies for every further variable you add to `arrange()`.

```{r include = FALSE}
# double arrange
```
```{r 23-double-arrange}
flights %>%
  arrange(dep_time, dep_delay)
```

Look at the data with `tibble::view()`

```{r include = FALSE}
# double arrange view
```
```{r 23-double-arrange-view}
flights %>%
  arrange(dep_time, dep_delay) %>%
  view()
```

You can combine `filter()` and `arrange()` (they even commute, though it seems more natural to first filter and then arrange).

```{r include = FALSE}
# filter double arrange view
```
```{r 23-filter-double-arrange-view}
flights %>%
  filter(dep_time < 600) %>%
  arrange(dep_time, dep_delay) %>%
  view()
```

...add one more filter:

```{r include = FALSE}
# filter 2 double arrange view
```
```{r 23-filter-2-double-arrange-view}
flights %>%
  filter(dep_time < 600) %>%
  filter(month >= 10) %>%
  arrange(dep_time, dep_delay) %>%
  view()
```

You can also use an expression involving one of the dataset's variables.

```{r include = FALSE}
# another filter arrange view
```
```{r 23-another-filter-arrange-view}
flights %>%
  filter(month == 4) %>%
  arrange(is.na(dep_time)) %>%
  view()
```

The reason for the result you just saw in the view of the filtered dataset is, that the binary result of the expression (`TRUE`, `FALSE`) is sorted `FALSE`-first (alphabetically).

Let's give it a twist:

```{r include = FALSE}
# another filter arrange
```
```{r 23-another-filter-arrange}
flights %>%
  filter(month == 4) %>%
  arrange(!is.na(dep_time))
```

Add another filter to further reduce the dataset and make it easier to handle:

```{r include = FALSE}
# another 2 filters arrange view
```
```{r 23-another-2-filters-arrange-view}
flights %>%
  filter(month == 4) %>%
  filter(day == 1) %>%
  arrange(!is.na(dep_time)) %>%
  view()
```

Sorting the dataset according to which flights arrived earliest on 1 April 2013:

```{r include = FALSE}
# another 2 filters arrange arr time view
```
```{r 23-another-2-filters-arrange-arr-time-view}
flights %>%
  filter(month == 4) %>%
  filter(day == 1) %>%
  arrange(arr_time) %>%
  view()
```

Invert the sorting by either...

```{r include = FALSE}
# Descending
```
```{r 23-descending}
flights %>%
  filter(month == 4) %>%
  filter(day == 1) %>%
  arrange(-arr_time) %>%
  view()
```

... or:

```{r include = FALSE}
# Descending 2
```
```{r 23-descending-2}
flights %>%
  filter(month == 4) %>%
  filter(day == 1) %>%
  arrange(desc(arr_time)) %>%
  view()
```

You can mix sorting in an ascending and a descending manner by doing the following:

```{r include = FALSE}
# Ascending and descending
```
```{r 23-ascending-and-descending}
flights %>%
  filter(month == 4) %>%
  filter(day == 1) %>%
  arrange(dep_time, desc(arr_time)) %>%
  view()
```
