[
["index.html", "Visualization, transformation and reporting with the tidyverse Preface Links Package versions used License", " Visualization, transformation and reporting with the tidyverse Kirill Müller, Tobias Schieferdecker 19 November 2019, 21:19 CET Preface See the controls at the top of the website for searching, font size, editing, and a link to the PDF version of the material. Links This website: https://krlmlr.github.io/vistransrep/ Scripts and installation instructions: https://github.com/krlmlr/vistransrep-proj/tree/master Prepared scripts: https://github.com/krlmlr/vistransrep-proj/tree/master/script Live code: https://github.com/krlmlr/vistransrep-proj/tree/master/live The source project for this material: https://github.com/krlmlr/vistransrep Package versions used Click to expand withr::with_options(list(width = 80), print(sessioninfo::session_info())) ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 3.6.1 (2017-01-27) ## os Ubuntu 16.04.6 LTS ## system x86_64, linux-gnu ## ui X11 ## language en_US.UTF-8 ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2019-11-19 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## askpass 1.1 2019-01-13 [1] CRAN (R 3.6.1) ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 3.6.1) ## backports 1.1.5 2019-10-02 [1] CRAN (R 3.6.1) ## bookdown 0.15 2019-11-12 [1] CRAN (R 3.6.1) ## broom 0.5.2 2019-04-07 [1] CRAN (R 3.6.1) ## cellranger 1.1.0 2016-07-27 [1] CRAN (R 3.6.1) ## cli 1.1.0 2019-03-19 [1] CRAN (R 3.6.1) ## codetools 0.2-16 2018-12-24 [3] CRAN (R 3.6.1) ## colorspace 1.4-1 2019-03-18 [1] CRAN (R 3.6.1) ## crayon 1.3.4 2017-09-16 [1] CRAN (R 3.6.1) ## crosstalk 1.0.0 2016-12-21 [1] CRAN (R 3.6.1) ## data.table 1.12.6 2019-10-18 [1] CRAN (R 3.6.1) ## digest 0.6.22 2019-10-21 [1] CRAN (R 3.6.1) ## dplyr * 0.8.3 2019-07-04 [1] CRAN (R 3.6.1) ## DT 0.10 2019-11-12 [1] CRAN (R 3.6.1) ## ellipsis 0.3.0 2019-09-20 [1] CRAN (R 3.6.1) ## evaluate 0.14 2019-05-28 [1] CRAN (R 3.6.1) ## fansi 0.4.0 2018-10-05 [1] CRAN (R 3.6.1) ## farver 2.0.1 2019-11-13 [1] CRAN (R 3.6.1) ## fastmap 1.0.1 2019-10-08 [1] CRAN (R 3.6.1) ## forcats * 0.4.0 2019-02-17 [1] CRAN (R 3.6.1) ## generics 0.0.2 2018-11-29 [1] CRAN (R 3.6.1) ## ggplot2 * 3.2.1 2019-08-10 [1] CRAN (R 3.6.1) ## ggpubr 0.2.4 2019-11-14 [1] CRAN (R 3.6.1) ## ggsignif 0.6.0 2019-08-08 [1] CRAN (R 3.6.1) ## git2r 0.26.1 2019-06-29 [1] CRAN (R 3.6.1) ## glue 1.3.1 2019-03-12 [1] CRAN (R 3.6.1) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 3.6.1) ## haven 2.2.0 2019-11-08 [1] CRAN (R 3.6.1) ## here * 0.1 2017-05-28 [1] CRAN (R 3.6.1) ## hms 0.5.2 2019-10-30 [1] CRAN (R 3.6.1) ## htmltools 0.4.0 2019-10-04 [1] CRAN (R 3.6.1) ## htmlwidgets 1.5.1 2019-10-08 [1] CRAN (R 3.6.1) ## httpuv 1.5.2 2019-09-11 [1] CRAN (R 3.6.1) ## httr 1.4.1 2019-08-05 [1] CRAN (R 3.6.1) ## jsonlite 1.6 2018-12-07 [1] CRAN (R 3.6.1) ## knitr 1.26 2019-11-12 [1] CRAN (R 3.6.1) ## labeling 0.3 2014-08-23 [1] CRAN (R 3.6.1) ## later 1.0.0 2019-10-04 [1] CRAN (R 3.6.1) ## lattice 0.20-38 2018-11-04 [3] CRAN (R 3.6.1) ## lazyeval 0.2.2 2019-03-15 [1] CRAN (R 3.6.1) ## leaflet * 2.0.3 2019-11-16 [1] CRAN (R 3.6.1) ## lifecycle 0.1.0 2019-08-01 [1] CRAN (R 3.6.1) ## lubridate 1.7.4 2018-04-11 [1] CRAN (R 3.6.1) ## magrittr 1.5 2014-11-22 [1] CRAN (R 3.6.1) ## MASS 7.3-51.4 2019-03-31 [3] CRAN (R 3.6.1) ## memoise 1.1.0 2017-04-21 [1] CRAN (R 3.6.1) ## mime 0.7 2019-06-11 [1] CRAN (R 3.6.1) ## modelr 0.1.5 2019-08-08 [1] CRAN (R 3.6.1) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 3.6.1) ## nlme 3.1-140 2019-05-12 [3] CRAN (R 3.6.1) ## nycflights13 * 1.0.1 2019-09-16 [1] CRAN (R 3.6.1) ## openssl 1.4.1 2019-07-18 [1] CRAN (R 3.6.1) ## pillar 1.4.2 2019-06-29 [1] CRAN (R 3.6.1) ## pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 3.6.1) ## plotly 4.9.1 2019-11-07 [1] CRAN (R 3.6.1) ## plyr 1.8.4 2016-06-08 [1] CRAN (R 3.6.1) ## promises 1.1.0 2019-10-04 [1] CRAN (R 3.6.1) ## purrr * 0.3.3 2019-10-18 [1] CRAN (R 3.6.1) ## R6 2.4.1 2019-11-12 [1] CRAN (R 3.6.1) ## RColorBrewer 1.1-2 2014-12-07 [1] CRAN (R 3.6.1) ## Rcpp 1.0.3 2019-11-08 [1] CRAN (R 3.6.1) ## readr * 1.3.1 2018-12-21 [1] CRAN (R 3.6.1) ## readxl 1.3.1 2019-03-13 [1] CRAN (R 3.6.1) ## reshape2 1.4.3 2017-12-11 [1] CRAN (R 3.6.1) ## rlang 0.4.1.9000 2019-11-18 [1] Github (r-lib/rlang@31fb60a) ## rmarkdown 1.17 2019-11-13 [1] CRAN (R 3.6.1) ## rprojroot 1.3-2 2018-01-03 [1] CRAN (R 3.6.1) ## rstudioapi 0.10 2019-03-19 [1] CRAN (R 3.6.1) ## rvest 0.3.5 2019-11-08 [1] CRAN (R 3.6.1) ## scales 1.1.0 2019-11-18 [1] CRAN (R 3.6.1) ## sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 3.6.1) ## shiny 1.4.0 2019-10-10 [1] CRAN (R 3.6.1) ## stringi 1.4.3 2019-03-12 [1] CRAN (R 3.6.1) ## stringr * 1.4.0 2019-02-10 [1] CRAN (R 3.6.1) ## tibble * 2.1.3 2019-06-06 [1] CRAN (R 3.6.1) ## tic 0.2.13.9021 2019-11-18 [1] Github (ropenscilabs/tic@9a5f965) ## tidyr * 1.0.0 2019-09-11 [1] CRAN (R 3.6.1) ## tidyselect 0.2.5 2018-10-11 [1] CRAN (R 3.6.1) ## tidyverse * 1.2.1 2017-11-14 [1] CRAN (R 3.6.1) ## utf8 1.1.4 2018-05-24 [1] CRAN (R 3.6.1) ## vctrs 0.2.0 2019-07-05 [1] CRAN (R 3.6.1) ## viridisLite 0.3.0 2018-02-01 [1] CRAN (R 3.6.1) ## withr 2.1.2 2018-03-15 [1] CRAN (R 3.6.1) ## xaringan 0.13 2019-10-30 [1] CRAN (R 3.6.1) ## xfun 0.11 2019-11-12 [1] CRAN (R 3.6.1) ## xml2 1.2.2 2019-08-09 [1] CRAN (R 3.6.1) ## xtable 1.8-4 2019-04-21 [1] CRAN (R 3.6.1) ## yaml 2.2.0 2018-07-25 [1] CRAN (R 3.6.1) ## zeallot 0.1.0 2018-01-28 [1] CRAN (R 3.6.1) ## ## [1] /home/travis/R/Library ## [2] /usr/local/lib/R/site-library ## [3] /home/travis/R-bin/lib/R/library License Licensed under CC-BY-NC 4.0. "],
["introduction.html", "1 Introduction 1.1 Speakers 1.2 Overview", " 1 Introduction The tidyverse has quickly developed over the last years. Its first implementation as a collection of partly older packages was in the second half of 2016. All its packages “share an underlying design philosophy, grammar, and data structures.”1 It is for sure difficult to tell, if “learning the tidyverse” is a hard task, since the result of this assessment might differ from person to person. We do believe though, that there are concepts in its approach, which – when grasped – have the potential to increase one’s productivity, since code creation will seem more natural. While this might be true for all languages (once you speak it well enough, things go smoothly), in our opinion the tidyverse worth exploring in depth, since it is consistent: an especially well designed framework that aims at making data analysis and programming intuitive, evolving: constantly deepened understanding for challenges arising in modern data analysis leads to improving ergonomic user interfaces. 1.1 Speakers Kirill Müller (@krlmlr) Patrick Schratz (@pat-s) M.Sc. Geoinformatics Researcher/Research Engineer at University of Jena and LMU Munich PhD Candidate Unix &amp; R enthusiast Author/Contributor/Maintainer of several R packages: (mlr3, mlr) sperrorest oddsratio xaringan circle RQGIS travis tic … 1.2 Overview This course covers several topics, which everyone working more intently with the tidyverse almost inevitably needs to deal with at some point or another. The topics are organized in chapters that contain mostly R code with output and text. In each section, exercises are provided. citation from tidyverse homepage↩ "],
["visualization.html", "2 Visualization 2.1 Basics for visualisation in R using {ggplot2} 2.2 Tweaks and tricks 2.3 Labels and layers 2.4 Statistical summaries 2.5 Facet plots", " 2 Visualization Embracing the grammar of graphics. This chapter discusses plotting with the ggplot2 package. 2.1 Basics for visualisation in R using {ggplot2} Click here to show setup code. library(tidyverse) In the {tidyverse} the standard package for visualisation is {ggplot2}. The functions of this package follow a quite unique logic (the “grammar of graphics”) and therefore require a special syntax. In this section we want to give a short introduction, how to get started with {ggplot2}. The main function in the package is ggplot(), which prepares/creates a graph. By setting the arguments of the function, you can: 1. choose the dataset to be plotted in the argument data 2. choose the mapping of the variables to the axes (or further forms of setting apart data) in the argument mapping. This argument takes the result of the function aes(), which you will get to know in many different examples. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) This created only an empty plot, because we did not tell {ggplot2}, which geometry we want to use to display the result. We do this by adding (literally using + after the ggplot()-call) a different function starting with geom_ to provide this information. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point() This is maybe the most basic plot you can create. To map a different variable than disp to the x-axis, change the respective argument in aes(). ggplot( data = mpg, mapping = aes(x = cyl, y = hwy) ) + geom_point() You can exchange the variables to be plotted freely, without changing anything else to the rest of the code. ggplot( data = mpg, mapping = aes(x = hwy, y = cty) ) + geom_point() 2.2 Tweaks and tricks Click here to show setup code. library(tidyverse) Change the color of the plotted data by setting the color argument in the geom()-function to a character variable with the color name. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point( color = &quot;red&quot; ) ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point( color = &quot;blue&quot; ) ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point( color = &quot;green&quot; ) Different colors can be mapped to the values of a variable as a further aesthetic property of the plot. The class variable is discrete and leads to a discrete color scale. ggplot( data = mpg, mapping = aes(x = displ, y = hwy, color = class) ) + geom_point() The cty attribute is continuous, the color scale is adapted accordingly. ggplot( data = mpg, mapping = aes(x = displ, y = hwy, color = cty) ) + geom_point() One more degree of freedom is the shape of the symbols to be plotted. The warning indicates that a plot should not use too many different shapes. ggplot( data = mpg, mapping = aes( x = displ, y = hwy, shape = class ) ) + geom_point() ## Warning: The shape palette can deal with a maximum of 6 discrete values because ## more than 6 becomes difficult to discriminate; you have 7. Consider ## specifying shapes manually if you must have them. ## Warning: Removed 62 rows containing missing values (geom_point). Variables with fewer classes are fine. Color and shape can be combined too. ggplot( data = mpg, mapping = aes( x = displ, y = hwy, color = class, shape = drv ) ) + geom_point() And last but not least, the size of the plotted symbols can be linked to numeric values of the mapped variable. ggplot( data = mpg, mapping = aes( x = displ, y = hwy, size = cty ) ) + geom_point() You can mix different aesthetic mappings in order to produce a plot with densely packed information. ggplot( data = mpg, mapping = aes( x = displ, y = hwy, color = class, size = cty ) ) + geom_point() Choosing a specific color in the mapping-argument of ggplot() does not work, since a mapping of a variable to an aesthetic is expected. Let’s try passing a color anyway… try( ggplot( data = mpg, mapping = aes( x = displ, y = hwy, color = blue ) ) + geom_point() ) ## Error in FUN(X[[i]], ...): object &#39;blue&#39; not found R treats objects without quotation marks in a special way, expecting them to be variables. Since blue is not a variable of mpg, this did not work. Use quotation marks if you mean a string, as opposed to a variable or object name. mpg ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## # … with 231 more rows &quot;mpg&quot; ## [1] &quot;mpg&quot; So what if we pass the color as a character variable? ggplot( data = mpg, mapping = aes( x = displ, y = hwy, color = &quot;blue&quot; ) ) + geom_point() At least there was no error, but now the constant value blue is mapped to the first default color of the color mapping, which happens to be red. We could have been fooled, if it had been blue. Manual aesthetics must be specified in the geom: ggplot( data = mpg, mapping = aes( x = displ, y = hwy ) ) + geom_point( color = &quot;blue&quot; ) Semi-transparency is another way to better display your data. This is useful to get an impression of how many data points share the same coordinates. ggplot( data = mpg, mapping = aes( x = displ, y = hwy ) ) + geom_point(alpha = 0.2) Within the aes()-function you can not only provide the bare variable of the data set, but you can also pass a function of a variable. ggplot( data = mpg, mapping = aes( x = displ, y = 2.35 / hwy ) ) + geom_point() Trying to map aesthetics in the geom()-function, does not work. try( ggplot( data = mpg, mapping = aes( x = displ, y = 2.35 / hwy ) ) + geom_point(color = class) ) ## Error in rep(value[[k]], length.out = n): attempt to replicate an object of type &#39;builtin&#39; 2.3 Labels and layers Click here to show setup code. library(tidyverse) For character variables there is further way of integrating its value to a plot. geom_text() takes a label argument, which influences the plot in the following way. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_text(label = &quot;A&quot;) Let’s try to map this argument to a variable (here: drv) of our dataset in the mapping argument of ggplot(). ggplot( data = mpg, mapping = aes(x = displ, y = hwy, label = &quot;drv&quot;) ) + geom_text() Right, of course we need to pass the variable without quotation marks, otherwise it is interpreted as a (constant) character variable. When changing this, a vector with the values of the variable is passed on to geom_text(). This is one way of including the values of character variables in a plot. ggplot( data = mpg, mapping = aes(x = displ, y = hwy, label = drv) ) + geom_text() By adding more than one geom()-function, more than one geometry is added to the plot. ggplot( data = mpg, mapping = aes(x = displ, y = hwy, label = drv) ) + geom_point() + geom_text() Since this looks just slightly odd, let’s try to make it more apparent, what is happening. ggplot( data = mpg, mapping = aes(x = displ, y = hwy, label = drv) ) + geom_point(color = &quot;blue&quot;) + geom_text(size = 10) It is also possible ot specify the mapping in the geom()-function. This way, when adding more than one geometry, you can choose different specifications for the mapping in each of the geom()-functions. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point(color = &quot;blue&quot;) + geom_text( mapping = aes(color = class, label = drv), size = 10, alpha = 0.2 ) This can be dangerous sometimes though. A good approach is always to define the mapping globally in ggplot() when possible. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point() + geom_rug() This would be redundant: ggplot( data = mpg ) + geom_point(mapping = aes(x = displ, y = hwy)) + geom_rug(mapping = aes(x = displ, y = hwy)) And here we have a mismatch between the two geometries, since the y-mapping is referring to different variables of the dataset. ggplot( data = mpg ) + geom_point(mapping = aes(x = displ, y = hwy)) + geom_rug(mapping = aes(x = displ, y = cty)) Displaying a scatter plot with an overlaid smooth curve fitted to the data is made very easy by the geometry function geom_smooth() ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; The default for the smoothing method is set to auto, which translates to a LOESS (locally estimated scatterplot smoothing) method, when dealing with fewer than 1000 observations. Changing the method to “lm”, a linear model will be fitted and displayed in your plot. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point() + geom_smooth(method = &quot;lm&quot;) 2.4 Statistical summaries Click here to show setup code. library(tidyverse) Some geom()-functions do some transformations and calculations behind the scenes before the data are visualized. One such function is geom_smooth() from the last section. Also geom_bar() does some transformations first. It just needs a mapping for the x-axis. Once that is done, the y-values displayed for each value of the x-variable are the numbers of of times that the x-value occurs in the dataset. So basically the different values are counted. ggplot( data = mpg, mapping = aes(x = class) ) + geom_bar() ggplot( data = mpg, mapping = aes(x = hwy) ) + geom_histogram(bins = 20) ggplot( data = mpg, mapping = aes(y = hwy) ) + geom_boxplot() ggplot( data = mpg, mapping = aes(x = class, y = hwy) ) + geom_boxplot() ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 2.5 Facet plots Click here to show setup code. library(tidyverse) One helpful feature that {ggplot2} offers is the facet plot. This means, that for each value of a given variable a different sub-plot is created. The relevant functions for this are facet_wrap() and facet_grid(). The former can be used like this. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point() + facet_wrap(~ class) The latter has a few more options that you can play with. Primarily, you can pass two variables to the function, one of which will determine the facetting along the rows and the other will determine the column facetting. ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point() + facet_grid(year ~ drv) "],
["transformation.html", "3 Transformation 3.1 Package: {conflicted} 3.2 Filtering: dplyr::filter() 3.3 Sort rows: dplyr::arrange() 3.4 The pipe 3.5 Pick columns: dplyr::select() 3.6 Create new columns based on old ones: dplyr::mutate() 3.7 Summarize data (by groups): dplyr::summarize(), dplyr::group_by() + dplyr::ungroup() 3.8 Summary-plots", " 3 Transformation Using a consistent grammar of data manipulation. This chapter discusses data transformation with the dplyr package. 3.1 Package: {conflicted} Click here to show setup code. library(tidyverse) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package This section is dedicated to show you the basic building blocks (i.e. functions) of data analysis in R within the {tidyverse}. The package providing these is {dplyr}. Before starting, we would like to mention the package {conflicted}, which when loaded, will help detecting functions of the same name from different packages (an error is thrown in case of such situations). It furthermore helps to resolve these situations, by allowing you to choose, the function of which package you prefer (conflicted::conflict_prefer()). You can see an example in the setup code. Last time we stopped with facet-plots, e.g. like this one here: my_mpg &lt;- mpg ggplot( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_point() + facet_grid(year ~ drv) 3.2 Filtering: dplyr::filter() Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package During this lecture we will be working with data from the package {nycflights13}, which contains flights in the year 2013 with their departure in New York City (airports: JFK, LGA or EWR) to destinations in the United States, Puerto Rico, and the American Virgin Islands. flights ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## # … with 3.368e+05 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; ?flights The function dplyr::filter() helps you to reduce your dataset to the observations (rows) of interest. The filter condition can use any of the dataset’s variables and needs to be a logical expression. flights %&gt;% filter(dep_time &lt; 600) ## # A tibble: 8,730 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## # … with 8,727 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; If you use one or more variables of the dataset in the filter condition, a vectorized evaluation of the condition is taking place. Generally you can provide any logical vector with a length equal to the number of rows (or alternatively equal to 1, if you want to keep/drop all rows). flights %&gt;% filter(is.na(dep_time)) ## # A tibble: 8,255 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 NA 1630 NA NA 1815 ## 2 2013 1 1 NA 1935 NA NA 2240 ## 3 2013 1 1 NA 1500 NA NA 1825 ## # … with 8,252 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Use &amp; or multiple filters to return only rows that match both criteria: flights %&gt;% filter(dep_time &lt; 600 &amp; arr_time &gt; 2200) ## # A tibble: 0 x 19 ## # … with 19 variables: year &lt;int&gt;, month &lt;int&gt;, day &lt;int&gt;, dep_time &lt;int&gt;, ## # sched_dep_time &lt;int&gt;, dep_delay &lt;dbl&gt;, arr_time &lt;int&gt;, ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; flights %&gt;% filter(dep_time &gt;= 700 &amp; arr_time &lt; 800) ## # A tibble: 10,654 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 1929 1920 9 3 7 ## 2 2013 1 1 1939 1840 59 29 2151 ## 3 2013 1 1 2058 2100 -2 8 2359 ## # … with 1.065e+04 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; flights %&gt;% filter(dep_time &gt;= 700) %&gt;% filter(arr_time &lt; 800) ## # A tibble: 10,654 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 1929 1920 9 3 7 ## 2 2013 1 1 1939 1840 59 29 2151 ## 3 2013 1 1 2058 2100 -2 8 2359 ## # … with 1.065e+04 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Use | to return all rows that match either criterion or both: flights %&gt;% filter(dep_time &lt; 600 | arr_time &gt; 2200) ## # A tibble: 40,879 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## # … with 4.088e+04 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 3.3 Sort rows: dplyr::arrange() Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package The function dplyr::arrange() sorts the rows of the dataset according to the values of the variable(s) you are providing. flights %&gt;% arrange(dep_time) ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 13 1 2249 72 108 2357 ## 2 2013 1 31 1 2100 181 124 2225 ## 3 2013 11 13 1 2359 2 442 440 ## # … with 3.368e+05 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; When providing multiple variables as arguments for ... (the ellipsis), the dataset is first sorted accorcing to the values of the first variable. Wherever these values occur more than once, another sorting takes place within those groups, according to the second variable you provided. The same rule applies for every further variable you add to arrange(). flights %&gt;% arrange(dep_time, dep_delay) ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 11 13 1 2359 2 442 440 ## 2 2013 12 16 1 2359 2 447 437 ## 3 2013 12 20 1 2359 2 430 440 ## # … with 3.368e+05 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; You can combine filter() and arrange(). flights %&gt;% filter(dep_time &lt; 600) %&gt;% filter(month &gt;= 10) %&gt;% arrange(dep_time, dep_delay) %&gt;% view() You can use arrange() with arbitrary expressions. flights %&gt;% filter(month == 4) %&gt;% filter(day == 1) %&gt;% arrange(is.na(dep_time)) %&gt;% view() The reason for the result you just saw in the view of the filtered dataset is, that the binary result of the expression (TRUE, FALSE) is sorted FALSE first (lexicographically). Let’s give it a twist: flights %&gt;% filter(month == 4) %&gt;% filter(day == 1) %&gt;% arrange(!is.na(dep_time)) %&gt;% view() Sorting the dataset according to which flights arrived earliest on April 1, 2013: flights %&gt;% filter(month == 4) %&gt;% filter(day == 1) %&gt;% arrange(arr_time) %&gt;% view() Invert the sorting by either… flights %&gt;% filter(month == 4) %&gt;% filter(day == 1) %&gt;% arrange(-arr_time) %&gt;% view() … or: flights %&gt;% filter(month == 4) %&gt;% filter(day == 1) %&gt;% arrange(desc(arr_time)) %&gt;% view() You can mix sorting in an ascending and a descending manner: flights %&gt;% filter(month == 4) %&gt;% filter(day == 1) %&gt;% arrange(dep_time, desc(arr_time)) %&gt;% view() 3.4 The pipe Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package We already heavily used it today, but what exactly are the characteristics of %&gt;%, better known as “the pipe”? early_flights &lt;- flights %&gt;% filter(dep_time &lt; 600) The above is just another way of writing: early_flights &lt;- filter(flights, dep_time &lt; 600) The manual describes this operator in detail: ?&quot;%&gt;%&quot; With the pipe, code can be read in a natural way, from left to right. The following snippet extracts all early flights from October till December, ordered by departure time and then departure delay and displays it. Note how the reading corresponds to the code. flights %&gt;% filter(dep_time &lt; 600) %&gt;% filter(month &gt;= 10) %&gt;% arrange(dep_time, dep_delay) %&gt;% view() This is possible, because all transformation verbs (filter(), arrange(), view()) accept the main input (a tibble) as the first argument and also return a tibble. The following three codes are equivalent, but are more difficult to write, to read and to maintain. Naming is hard. Trying to give each intermediate result a name is exhausting. Introducing an additional step in this sequence of operations is prone to errors. early_flights &lt;- filter(flights, dep_time &lt; 600) early_flights_oct_dec &lt;- filter(early_flights, month &gt;= 10) early_flights_oct_dec_sorted &lt;- arrange(early_flights_oct_dec, dep_time, dep_delay) view(early_flights_oct_dec_sorted) We can keep using the same variable, e.g. x, to avoid naming. This adds noise compared to the pipe. x &lt;- flights x &lt;- filter(x, dep_time &lt; 600) x &lt;- filter(x, month &gt;= 10) x &lt;- arrange(x, dep_time, dep_delay) view(x) We can avoid intermediate variables. This disconnects the verbs from their arguments and is very difficult to read. view( arrange( filter( filter( flights, dep_time &lt; 600 ), month &gt;= 10 ), dep_time, dep_delay ) ) 3.4.1 Further advantages When working on a code chunk consisting of subsequent transformations connected by pipes, it can be useful to end the pipeline with either I or view(). flights %&gt;% filter(dep_time &lt; 600) %&gt;% filter(month &gt;= 10) %&gt;% I ## # A tibble: 1,894 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## * &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 10 1 447 500 -13 614 648 ## 2 2013 10 1 522 517 5 735 757 ## 3 2013 10 1 536 545 -9 809 855 ## # … with 1,891 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; ##arrange(dep_time, dep_delay) %&gt;% ##view() Once the chunk does what you expect it to do, do not forget to remove the I or view() call. try( arrange(dep_time, dep_delay) %&gt;% view() ) ## Error in arrange(dep_time, dep_delay) : object &#39;dep_time&#39; not found To rearrange rows, you can use the shortcut Alt + Cursor up/down. In a piped expression, no further editing is necessary! 3.5 Pick columns: dplyr::select() Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package With dplyr::select() you can (de-)select and/or rename columns of your dataset. The basic operation is like in the following examples: flights %&gt;% select(year, month, day) ## # A tibble: 336,776 x 3 ## year month day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 ## 2 2013 1 1 ## 3 2013 1 1 ## # … with 3.368e+05 more rows flights %&gt;% select(-year) ## # A tibble: 336,776 x 18 ## month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 1 1 517 515 2 830 819 ## 2 1 1 533 529 4 850 830 ## 3 1 1 542 540 2 923 850 ## # … with 3.368e+05 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Renaming works by addressing an existing column on the right hand side of an equality sign and providing the new name of the column on its left hand side. flights %&gt;% select( year, month, day, departure_delay = dep_delay, arrival_delay = arr_delay ) ## # A tibble: 336,776 x 5 ## year month day departure_delay arrival_delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 2 11 ## 2 2013 1 1 4 20 ## 3 2013 1 1 2 33 ## # … with 3.368e+05 more rows With backticks, it is possible, but not advised, to use arbitrary characters (including spaces) in column names: flights_with_spaces &lt;- flights %&gt;% select( year, month, day, `Departure delay` = dep_delay, `Arrival delay` = arr_delay ) %&gt;% filter( `Arrival delay` &lt; 0 ) Address them in the same way, if the dataset already has such variables: flights_with_spaces %&gt;% select( year, month, day, dep_delay = `Departure delay`, arr_delay = `Arrival delay` ) ## # A tibble: 188,933 x 5 ## year month day dep_delay arr_delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 -1 -18 ## 2 2013 1 1 -6 -25 ## 3 2013 1 1 -3 -14 ## # … with 1.889e+05 more rows The {janitor} package helps fixing issues with colum names automatically. Select helpers allow selecting multiple related columns conveniently. flights %&gt;% select(origin, dest, ends_with(&quot;_time&quot;)) ## # A tibble: 336,776 x 7 ## origin dest dep_time sched_dep_time arr_time sched_arr_time air_time ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 EWR IAH 517 515 830 819 227 ## 2 LGA IAH 533 529 850 830 227 ## 3 JFK MIA 542 540 923 850 160 ## # … with 3.368e+05 more rows 3.6 Create new columns based on old ones: dplyr::mutate() Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package conflict_prefer(&quot;lag&quot;, &quot;dplyr&quot;) ## [conflicted] Will prefer [34mdplyr::lag[39m over any other package With dplyr::mutate() you can add new columns to a table, e.g. making use of the already existing variables. How much faster than the scheduled time did the pilots manage to fly: flights %&gt;% mutate(recovery = dep_delay - arr_delay) ## # A tibble: 336,776 x 20 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## # … with 3.368e+05 more rows, and 12 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, ## # recovery &lt;dbl&gt; This is another building block added to the toolset: flights %&gt;% mutate(recovery = dep_delay - arr_delay) %&gt;% select(dep_delay, arr_delay, recovery) ## # A tibble: 336,776 x 3 ## dep_delay arr_delay recovery ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 11 -9 ## 2 4 20 -16 ## 3 2 33 -31 ## # … with 3.368e+05 more rows Work with the newly created variable just like with the original ones: flights %&gt;% mutate(recovery = dep_delay - arr_delay) %&gt;% select(dep_delay, arr_delay, recovery) %&gt;% arrange(recovery) ## # A tibble: 336,776 x 3 ## dep_delay arr_delay recovery ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -2 194 -196 ## 2 -2 179 -181 ## 3 180 345 -165 ## # … with 3.368e+05 more rows Assign the results to new variables. The old ones remain unchanged. recovery_data &lt;- flights %&gt;% mutate(recovery = dep_delay - arr_delay) %&gt;% select(dep_delay, arr_delay, recovery) %&gt;% arrange(recovery) recovery_data ## # A tibble: 336,776 x 3 ## dep_delay arr_delay recovery ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -2 194 -196 ## 2 -2 179 -181 ## 3 180 345 -165 ## # … with 3.368e+05 more rows Let’s look at a single airplane: flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% select(year, month, day, dep_time, arr_time) %&gt;% view() Adding the departure time of the next flight to the current row, respectively, using mutate() with lead(): flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% select(year, month, day, dep_time, arr_time) %&gt;% mutate(lead_dep_time = lead(dep_time)) %&gt;% view() The opposite effect to lead() can be realized using lag(): flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% select(year, month, day, dep_time, arr_time) %&gt;% mutate(lag_arr_time = lag(arr_time)) %&gt;% view() There is even a use-case for this in our little example. How long has our airplane been absent from NYC airports between each of its flights out? flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% select(year, month, day, dep_time, arr_time) %&gt;% mutate(lag_arr_time = lag(arr_time)) %&gt;% mutate(ground_time = dep_time - lag_arr_time) %&gt;% view() The negative values occur because not everything happens on the same day, implying that our method is still in need of some refinement. Nevertheless, let’s continue. A frequently used workflow is creating a helper variable at some point in the pipeline and then dropping it later on: flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% select(year, month, day, dep_time, arr_time) %&gt;% mutate(lag_arr_time = lag(arr_time)) %&gt;% mutate(ground_time = dep_time - lag_arr_time) %&gt;% select(-lag_arr_time) ## # A tibble: 111 x 6 ## year month day dep_time arr_time ground_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 830 NA ## 2 2013 1 8 1435 1717 605 ## 3 2013 1 9 717 812 -1000 ## # … with 108 more rows Let’s work some more with the flight data of our special plane. flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% view() The total air time of a plane up to and including a given flight can be calculated with base::cumsum(): flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% mutate(cum_air_time = cumsum(air_time)) %&gt;% select(air_time, cum_air_time) %&gt;% view() Creating a “flag” variable with mutate() which shows if a flight was on time or not: flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% mutate(delayed = if_else(arr_delay &gt; 0, &quot;delayed&quot;, &quot;on time&quot;)) %&gt;% select(arr_delay, delayed) ## # A tibble: 111 x 2 ## arr_delay delayed ## &lt;dbl&gt; &lt;chr&gt; ## 1 11 delayed ## 2 -29 on time ## 3 -3 on time ## # … with 108 more rows A more straightforward way to get the same (or at least a very similar and probably easier to work with) result: flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% mutate(delayed = arr_delay &gt; 0) %&gt;% select(arr_delay, delayed) ## # A tibble: 111 x 2 ## arr_delay delayed ## &lt;dbl&gt; &lt;lgl&gt; ## 1 11 TRUE ## 2 -29 FALSE ## 3 -3 FALSE ## # … with 108 more rows … easier to work with, because filter() can directly take logical arguments: flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% mutate(delayed = arr_delay &gt; 0) %&gt;% select(arr_delay, delayed) %&gt;% filter(delayed) ## # A tibble: 39 x 2 ## arr_delay delayed ## &lt;dbl&gt; &lt;lgl&gt; ## 1 11 TRUE ## 2 39 TRUE ## 3 54 TRUE ## # … with 36 more rows Negation for inverse filtering: flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% mutate(delayed = arr_delay &gt; 0) %&gt;% select(arr_delay, delayed) %&gt;% filter(!delayed) ## # A tibble: 72 x 2 ## arr_delay delayed ## &lt;dbl&gt; &lt;lgl&gt; ## 1 -29 FALSE ## 2 -3 FALSE ## 3 -20 FALSE ## # … with 69 more rows These are the flights that had no delay: on_time_flights &lt;- flights %&gt;% filter(tailnum == &quot;N14228&quot;) %&gt;% mutate(delayed = arr_delay &gt; 0) %&gt;% select(arr_delay, delayed) %&gt;% filter(!delayed) 3.7 Summarize data (by groups): dplyr::summarize(), dplyr::group_by() + dplyr::ungroup() Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package conflict_prefer(&quot;lag&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::lag[39m over any other package Often we want to draw just conclusions from larger datasets by gaining insight by using statistical (or other) methods for summarizing – and thus drastically reducing – the data: How much time did all planes spend in the air? flights %&gt;% select(air_time) %&gt;% mutate(total_air_time = sum(air_time, na.rm = TRUE)) ## # A tibble: 336,776 x 2 ## air_time total_air_time ## &lt;dbl&gt; &lt;dbl&gt; ## 1 227 49326610 ## 2 227 49326610 ## 3 160 49326610 ## # … with 3.368e+05 more rows The mutate() call adds a new variable with the same value across all rows. To reduce the result to a single row, use summarize(): flights %&gt;% summarize(total_air_time = sum(air_time, na.rm = TRUE)) ## # A tibble: 1 x 1 ## total_air_time ## &lt;dbl&gt; ## 1 49326610 Simple counts can be computed with n() inside summarize(): flights %&gt;% summarize(n = n()) ## # A tibble: 1 x 1 ## n ## &lt;int&gt; ## 1 336776 A variety of aggregate functions is supported: flights %&gt;% summarize(median = median(air_time, na.rm = TRUE)) ## # A tibble: 1 x 1 ## median ## &lt;dbl&gt; ## 1 129 It’s possible to produce two different summarizations at once: flights %&gt;% summarize( n = n(), mean_air_time = mean(air_time, na.rm = TRUE), median_air_time = median(air_time, na.rm = TRUE) ) ## # A tibble: 1 x 3 ## n mean_air_time median_air_time ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 336776 151. 129 The summarize() verb gains its full power in grouped operations. Surround with group_by() and ungroup() to compute summaries in groups defined by common values in one or more columns. In the next example, the same summary is computed separately for each origin airport. flights %&gt;% group_by(origin) %&gt;% summarize( n = n(), mean_air_time = mean(air_time, na.rm = TRUE), median_air_time = median(air_time, na.rm = TRUE) ) %&gt;% ungroup() ## # A tibble: 3 x 4 ## origin n mean_air_time median_air_time ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 EWR 120835 153. 130 ## 2 JFK 111279 178. 149 ## 3 LGA 104662 118. 115 The next example splits the data into one group for each day. flights %&gt;% group_by(year, month, day) %&gt;% summarize( n = n(), mean_air_time = mean(air_time, na.rm = TRUE), median_air_time = median(air_time, na.rm = TRUE) ) %&gt;% ungroup() ## # A tibble: 365 x 6 ## year month day n mean_air_time median_air_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 842 170. 149 ## 2 2013 1 2 943 162. 148 ## 3 2013 1 3 914 157. 148 ## # … with 362 more rows For quick exploration, the names of the new columns can be omitted: flights %&gt;% group_by(year, month, day) %&gt;% summarize( n(), mean(air_time, na.rm = TRUE), median(air_time, na.rm = TRUE) ) %&gt;% ungroup() ## # A tibble: 365 x 6 ## year month day `n()` `mean(air_time, na.rm = T… `median(air_time, na.rm = … ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 842 170. 149 ## 2 2013 1 2 943 162. 148 ## 3 2013 1 3 914 157. 148 ## # … with 362 more rows TRUE ## [1] TRUE TRUE ## [1] TRUE 3.8 Summary-plots Click here to show setup code. library(tidyverse) library(nycflights13) library(conflicted) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::filter[39m over any other package conflict_prefer(&quot;lag&quot;, &quot;dplyr&quot;) ## [conflicted] Removing existing preference ## [conflicted] Will prefer [34mdplyr::lag[39m over any other package Potentially surprisingly, mutate() can also work with the results of a ggplot() call. Let’s approach this step by step. Here is a basic barplot of flights$carrier: flights %&gt;% ggplot(aes(x = carrier)) + geom_bar() Same with one facet per month: flights %&gt;% ggplot(aes(x = carrier)) + geom_bar() + facet_wrap(~month) We can extract a function that takes any data and produces a barplot of the variable carrier: plot_fun &lt;- function(data) { data %&gt;% ggplot(aes(x = carrier)) + geom_bar() } plot_fun(flights) The result of ggplot() is first and foremost an object. Only when R tries to display it on the console a method is triggered, which causes it to show the graph in the “Viewer”. Therefore, we can use the group_by – summarize() – ungroup() pattern to produce one plot per group and store it in a new column: plot_df &lt;- flights %&gt;% group_by(month) %&gt;% summarize( plot = list(plot_fun(tibble(carrier))) ) %&gt;% ungroup() plot_df ## # A tibble: 12 x 2 ## month plot ## &lt;int&gt; &lt;list&gt; ## 1 1 &lt;gg&gt; ## 2 2 &lt;gg&gt; ## 3 3 &lt;gg&gt; ## # … with 9 more rows When using dplyr::pull() (this function “extracts” a variable from a data.frame and returns it as a normal vector), each of the plots will be subsequently displayed in your “Viewer”. plot_df %&gt;% pull() ## [[1]] ## ## [[2]] ## ## [[3]] ## ## [[4]] ## ## [[5]] ## ## [[6]] ## ## [[7]] ## ## [[8]] ## ## [[9]] ## ## [[10]] ## ## [[11]] ## ## [[12]] Use the left arrow to click through the different plots. "],
["best-practices.html", "4 Best practices 4.1 DESCRIPTION 4.2 R 4.3 roxygen2 4.4 testthat", " 4 Best practices R code is often organized in packages that can be installed from centralized repositories such as CRAN or GitHub. If you are new to writing R packages, this course cannot give a complete introduction into packages. It is still useful to embrace some very few concepts of R packages to gain access to a vast toolbox and also organize your code in a standardized way familiar to other users. With the first steps in place, the road to your first R package may become less steep. Create a DESCRIPTION file to declare dependencies and allow easy reloading of the functions you define Store your functions in .R files in the R/ directory in your project Scripts that you execute live in script/ or a similar directory Use roxygen2 to document your functions close to the source Write tests for your functions, e.g. with testthat See R packages for a more comprehensive treatment. 4.1 DESCRIPTION Create and open a new RStudio project. Then, create a DESCRIPTION file with usethis::use_description(): # install.packages(&quot;usethis&quot;) usethis::use_description() Double-check success: # install.packages(&quot;devtools&quot;) devtools::load_all() Declare that your project requires the tidyverse and the here package: usethis::use_package(&quot;here&quot;) # Currently doesn&#39;t work, add manually # https://github.com/r-lib/usethis/issues/760 # usethis::use_package(&quot;tidyverse&quot;) 4.2 R With a DESCRIPTION file defined, create a new .R file and save it in the R/ directory. (Create this directory if it does not exist.) Create a function in this file, save the file: hi &lt;- function(text = &quot;Hello, world!&quot;) { print(text) invisible(text) } Do not source the file. Restart R (with Ctrl + Shift + F10 in RStudio). Run devtools::load_all() again, you can use the shortcut Ctrl + Shift + L or Cmd + Shift + L in RStudio. Check that you can run hi() in the console: hi() ## [1] &quot;Hello, world!&quot; hi(&quot;Wow!&quot;) ## [1] &quot;Wow!&quot; Edit the function: hi &lt;- function(text = &quot;Wow!&quot;) { print(text) invisible(text) } Save the file, but do not source it. Run devtools::load_all() again, you can use the shortcut Ctrl + Shift + L or Cmd + Shift + L in RStudio. Check that the new implementation of hi() is active: hi() ## [1] &quot;Wow!&quot; All functions that are required for your project are stored in this directory. Do not store executable scripts, use a script/ directory. 4.3 roxygen2 The following intuitive annotation syntax is a standard way to create documentation for your functions: #&#39; Print a welcome message #&#39; #&#39; This function prints &quot;Wow!&quot;, or a custom text, on the console. #&#39; #&#39; @param text The text to print, &quot;Wow!&quot; by default. #&#39; #&#39; @return The `text` argument, invisibly. #&#39; #&#39; @examples #&#39; hi() #&#39; hi(&quot;Hello!&quot;) hi &lt;- function(text = &quot;Wow!&quot;) { print(text) invisible(text) } This annotation can be rendered to a nicely looking HTML page with the roxygen2 and pkgdown packages. All you need to do is provide (and maintain) it. 4.4 testthat Automated tests make sure that the functions you write today continue working tomorrow. Create your first test with usethis::use_test(): # install.packages(&quot;testthat&quot;) usethis::use_test(&quot;hi&quot;) The file tests/testthat/test-hi.R is created, with the following contents: test_that(&quot;multiplication works&quot;, { expect_equal(2 * 2, 4) }) Replace this predefined text with a test that makes more sense for us: test_that(&quot;hi() works&quot;, { expect_output(hi(), &quot;Wow&quot;) expect_output(hi(&quot;Hello&quot;), &quot;Hello&quot;) }) Run the new test with devtools::test(), you can use the shortcut Ctrl + Shift + T or Cmd + Shift + T in RStudio. Check that the test actually detects failures by modifying the implementation of hi() and rerunning the test: hi &lt;- function(text = &quot;Oops!&quot;) { print(text) invisible(text) } Run the new test with devtools::test(), you can use the shortcut Ctrl + Shift + T or Cmd + Shift + T in RStudio. One test should be failing now. "],
["references.html", "# References", " # References R for data science: https://r4ds.had.co.nz/ Row oriented workflows: https://github.com/jennybc/row-oriented-workflows#readme Advanced R: http://adv-r.had.co.nz/ Tidy evaluation: https://tidyeval.tidyverse.org/ R packages: http://r-pkgs.had.co.nz/ roxygen2: Vignettes in https://cran.r-project.org/package=roxygen2, especially: Introduction to roxygen2 Generating Rd files for an overview of available tags Write R documentation in Markdown How R searches and finds stuff: http://blog.obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/ What they forgot to teach you: https://whattheyforgot.org/ Parallel processing with a purrr-like interface: https://davisvaughan.github.io/furrr/ Tidyverse principles: https://principles.tidyverse.org/ Recursive lists to use in teaching and examples: https://github.com/jennybc/repurrrsive "]
]
